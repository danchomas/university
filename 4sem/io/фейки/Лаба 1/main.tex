\documentclass{report}

\usepackage[russian]{babel}
\usepackage{geometry}
\usepackage{minted2}
\usepackage[hidelinks]{hyperref}
\usepackage{xcolor}
\usepackage{xspace}
\usepackage{fancyhdr}
\usepackage{tocloft}
\usepackage{booktabs}
\usepackage{tikz}
\usepackage{titlesec}
\usepackage{tabularx}
\usepackage{setspace}
\usepackage{makecell}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{amsmath}
\usepackage{multirow}

\usetikzlibrary{shapes, arrows}
\usetikzlibrary{positioning}
\usetikzlibrary{shapes.geometric}
\usetikzlibrary{shapes.misc}
\usetikzlibrary{calc}
\usetikzlibrary{chains}

\tikzstyle{pf}=[circle, draw, text centered, minimum height = 2em]
\tikzstyle{con} = [draw, -latex']

\setcounter{MaxMatrixCols}{20}

\newcommand{\drawzalupa}[2]{
	\begin{figure}[H]
		%\begin{center}
		\centering
		\includegraphics[width=#2\textwidth]{#1}
		%\end{center}
	\end{figure}
}

\setlength{\cftaftertoctitleskip}{2pt}

\renewcommand{\cfttoctitlefont}{\LARGE\bfseries}

\titleformat{\chapter}{\normalfont\LARGE\bfseries}{\thechapter}{20pt}{\LARGE\bfseries}
\titlespacing*{\chapter}{0pt}{0pt}{20pt}

\pagestyle{fancy}

\fancyhf{} 

\fancyfoot[C]{\thepage} 

\renewcommand{\headrulewidth}{0pt} 

\renewcommand{\footrulewidth}{0pt}


\definecolor{pybg}{rgb}{0.95,0.95,0.95}


\geometry{left=3cm}
\geometry{right=1.5cm}
\geometry{top=2cm}
\geometry{bottom=2cm}

\counterwithout{figure}{chapter}


\newminted[code]{cpp}{
	bgcolor=pybg,
	baselinestretch=1.2,
	fontsize=\normalsize,
	tabsize=0,
	linenos,
	obeytabs=true,
	tabsize=4
}

\newcommand{\q}[1]{``#1''}

\begin{document}
	\begin{titlepage}
		\begin{center}
			МИНИСТЕРСТВО НАУКИ И ВЫСШЕГО ОБРАЗОВАНИЯ\linebreak 
			РОССИЙСКОЙ ФЕДЕРАЦИИ\medskip
			
			ФЕДЕРАЛЬНОЕ ГОСУДАРСТВЕННОЕ БЮДЖЕТНОЕ ОБРАЗОВАТЕЛЬНОЕ 
			УЧРЕЖДЕНИЕ ВЫСШЕГО ОБРАЗОВАНИЯ\medskip
			
			\textbf{
				«БЕЛГОРОДСКИЙ ГОСУДАРСТВЕННЫЙ \linebreak
				ТЕХНОЛОГИЧЕСКИЙ УНИВЕРСИТЕТ им. В. Г. ШУХОВА»\linebreak
				(БГТУ им. В.Г. Шухова)
			}\bigskip
			
			Кафедра программного обеспечения вычислительной техники и автоматизированных систем
			\vspace{5cm}
			
			\Large\textbf{Лабораторная работа №1}
			
			\large по дисциплине: Исследование операций\linebreak
			тема: \q{Исследование множества опорных планов системы ограничений
				задачи линейного программирования (задачи ЛП) в канонической
				форме}
		\end{center}\vspace{6cm}
		
		\begin{flushright}
			\begin{minipage}{7cm}
				Выполнил: ст. группы ПВ-231\\
				Столяров Захар\\
				\\
				Проверил: \\
				Вирченко Юрий Петрович\\
			\end{minipage}
		\end{flushright}\bigskip
		
		\
		
		\
		
		\
		
		\
		
		
		\begin{center}
			Белгород, 2025 г.
		\end{center}
	\end{titlepage}
	
	\newpage
	
	\setcounter{secnumdepth}{-1}
	\chapter{Лабораторная работа №1 <<Исследование множества опорных планов системы ограничений
		задачи линейного программирования (задачи ЛП) в канонической
		форме.>>}
	
	\textbf{Цель работы:} изучить метод Гаусса-Жордана и операцию
	замещения, а также освоить их применение к отысканию множества
	допустимых базисных видов системы линейных уравнений, и решению
	задачи линейного программирования простым перебором опорных
	решений.
	\begin{center}
		\textbf{Вариант 14}
	\end{center}
	\bigbreak
	\tableofcontents
	
	\chapter{Система уравнений моего варианта}
	
	\[
	\Large\left\{
	\begin{aligned}
		&-x_1 + 5x_2 - 4x_3 - 6x_4 + x_6 = -9 \\
		&8x_1 + x_2 - x_3 + 2x_5 + 3x_6 = 8 \\
		&4x_1 + 3x_2 - 2x_3 + 9x_4 + x_5 + 7x_6 = 1
	\end{aligned}
	\right.
	\]
	
	
	
	\chapter{Задание 1}
	\section{Составить программу для отыскания всех базисных видов системы
		линейных уравнений:}
	
	\section{Блок-схема функции gauss\_jordan}
	
	\drawzalupa{images/block1.png}{0.61}
	
	\newpage
	
	\drawzalupa{images/block2.png}{0.9}
	
	\newpage
	
	\drawzalupa{images/block3.png}{0.9}
	
	\section{Код программы}
	
	\begin{code}
#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>
#include <numeric>
#include <iomanip>

using namespace std;

const double EPS = 1e-9;

// Функция для перестановки столбцов в матрице
void rearrangeColumns(vector<vector<double>>& matrix, const vector<int>& basis) {
	int cols = matrix[0].size() - 1; // Исключаем столбец свободных членов
	for (auto& row : matrix) {
		vector<double> new_row;
		// Добавляем базисные столбцы
		for (int b : basis) new_row.push_back(row[b]);
		// Добавляем оставшиеся небазисные столбцы
		for (int c = 0; c < cols; ++c) {
			if (find(basis.begin(), basis.end(), c) == basis.end()) {
				new_row.push_back(row[c]);
			}
		}
		// Добавляем свободный член
		new_row.push_back(row.back());
		row = new_row;
	}
}

// Улучшенный метод Гаусса-Жордана с ведением журнала ведущих столбцов
void gauss_jordan(vector<vector<double>>& matrix, vector<int>& leading_columns) {
	int rows = matrix.size();
	int cols = matrix[0].size() - 1;
	leading_columns.clear();
	int lead = 0;
	
	for (int r = 0; r < rows && lead < cols; ++r) {
		// Поиск ненулевого элемента в столбце lead начиная с текущей строки
		int i = r;
		while (i < rows && abs(matrix[i][lead]) < EPS) ++i;
		if (i == rows) {
			++lead;
			--r;
			continue;
		}
		
		swap(matrix[i], matrix[r]);
		double div = matrix[r][lead];
		for (int j = lead; j <= cols; ++j) matrix[r][j] /= div;
		
		for (i = 0; i < rows; ++i) {
			if (i != r) {
				double factor = matrix[i][lead];
				for (int j = lead; j <= cols; ++j)
				matrix[i][j] -= factor * matrix[r][j];
			}
		}
		leading_columns.push_back(lead);
		++lead;
	}
}

// Функция для проверки, является ли комбинация допустимым базисом
bool is_valid_basis(const vector<int>& basis, const vector<int>& leading_columns) {
	if (leading_columns.size() != 3) return false;
	for (int lc : leading_columns)
	if (lc >= basis.size()) return false;
	return true;
}

// Функция для вывода решения с учетом переставленных столбцов
void print_solution(const vector<vector<double>>& matrix, const vector<int>& basis) {
	cout << "Базисные переменные: ";
	for (int b : basis) cout << "x" << b + 1 << " ";
	cout << "\nРешение:\n";
	
	vector<bool> is_basis_var(matrix[0].size() - 1, false);
	for (int b : basis) is_basis_var[b] = true;
	
	for (size_t r = 0; r < matrix.size(); ++r) {
		int lead_col = -1;
		for (size_t c = 0; c < basis.size(); ++c) {
			if (abs(matrix[r][c] - 1.0) < EPS) {
				lead_col = c;
				break;
			}
		}
		
		if (lead_col == -1) {
			if (abs(matrix[r].back()) > EPS)
			cout << "Система несовместна\n";
			continue;
		}
		
		int actual_var = basis[lead_col];
		cout << "x" << actual_var + 1 << " = " << fixed << setprecision(2) << matrix[r].back();
		
		for (size_t c = basis.size(); c < matrix[r].size() - 1; ++c) {
			if (abs(matrix[r][c]) > EPS) {
				cout << " - " << fixed << setprecision(2) << matrix[r][c]
				<< "*x" << (c >= basis.size() ?
				(matrix[0].size() - 1 > c ? c - basis.size() + basis.size() : 0) : c) + 1;
			}
		}
		cout << endl;
	}
	cout << "-------------------------\n";
}

void find_basic_solutions(vector<vector<double>> original, int num_vars) {
	int num_eqs = original.size();
	vector<int> vars(num_vars);
	iota(vars.begin(), vars.end(), 0);
	
	vector<bool> selector(num_vars);
	fill(selector.begin(), selector.begin() + num_eqs, true);
	
	int count = 0;
	do {
		vector<int> basis;
		for (int i = 0; i < num_vars; ++i)
		if (selector[i]) basis.push_back(i);
		if (basis.size() != num_eqs) continue;
		
		vector<vector<double>> matrix = original;
		rearrangeColumns(matrix, basis);
		
		vector<int> leading_columns;
		gauss_jordan(matrix, leading_columns);
		
		cout << "Комбинация базиса " << ++count << ":\n";
		cout << "Преобразованная матрица:\n";
		for (const auto& row : matrix) {
			for (double val : row) cout << fixed << setprecision(2) << setw(8) << val;
			cout << endl;
		}
		
		if (is_valid_basis(basis, leading_columns)) {
			print_solution(matrix, basis);
		}
		else {
			cout << "Не является допустимым базисом\n";
			cout << "-------------------------\n";
		}
		
	} while (prev_permutation(selector.begin(), selector.end()));
}

int main() {
	setlocale(LC_ALL, "Russian");
	vector<vector<double>> matrix = {
		{-1, 5, -4, -6, 0, 1, -9},
		{8, 1, -1, 0, 2, 3, 8},
		{4, 3, -2, 9, 1, 7, 1}
	};
	find_basic_solutions(matrix, 6);
	return 0;
}
	\end{code}
	
	\newpage
	
	Результат работы программы:
	
	\drawzalupa{images/task1.png}{1}
	
	\drawzalupa{images/task12.png}{1}
	
	\drawzalupa{images/task13.png}{1}
	
	\newpage
	
	Описание программы:
	\begin{enumerate}
		\item{Ввод данных:}
		
			\begin{itemize}
				\itemПрограмма запрашивает количество уравнений и переменных.
			
				\itemЗатем вводятся коэффициенты системы уравнений.
			\end{itemize}
		
		\item{Метод Гаусса-Жордана:}
		
			\begin{itemize}
				\itemМатрица приводится к приведённому ступенчатому виду.
			
				\itemВедущие элементы (первые ненулевые элементы в строках) становятся равными 1.
			
				\itemВсе остальные элементы в столбцах ведущих элементов обнуляются.
			\end{itemize}
		
		\item{Анализ решения:}
		
			\begin{itemize}
				\itemЕсли в процессе преобразований обнаруживается строка вида 0 0 ... 0 | b, где b != 0, система не имеет решений.
			
				\itemЕсли система имеет бесконечно много решений, программа указывает свободные переменные.
			
				\itemЕсли система имеет единственное решение, программа выводит его.
			\end{itemize}
			
	\end{enumerate}
	\chapter{Задание 2}
	\section{Организовать отбор опорных планов среди всех базисных решений,
	а также нахождение оптимального опорного плана методом
	прямого перебора. Целевая функция выбирается произвольно.}
	
	Пусть в нашем случае целевая функция будет равна сумме свободных членов в системе.
	
	Код программы:
	
	\begin{code}
#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>
#include <numeric>
#include <iomanip>

using namespace std;

const double EPS = 1e-9;

// Функция для перестановки столбцов в матрице
void rearrangeColumns(vector<vector<double>>& matrix, const vector<int>& basis) {
	int cols = matrix[0].size() - 1; // Исключаем столбец свободных членов
	for (auto& row : matrix) {
		vector<double> new_row;
		// Добавляем базисные столбцы
		for (int b : basis) new_row.push_back(row[b]);
		// Добавляем оставшиеся небазисные столбцы
		for (int c = 0; c < cols; ++c) {
			if (find(basis.begin(), basis.end(), c) == basis.end()) {
				new_row.push_back(row[c]);
			}
		}
		// Добавляем свободный член
		new_row.push_back(row.back());
		row = new_row;
	}
}

// Улучшенный метод Гаусса-Жордана с ведением журнала ведущих столбцов
void gauss_jordan(vector<vector<double>>& matrix, vector<int>& leading_columns) {
	int rows = matrix.size();
	int cols = matrix[0].size() - 1;
	leading_columns.clear();
	int lead = 0;
	
	for (int r = 0; r < rows && lead < cols; ++r) {
		// Поиск ненулевого элемента в столбце lead начиная с текущей строки
		int i = r;
		while (i < rows && abs(matrix[i][lead]) < EPS) ++i;
		if (i == rows) {
			++lead;
			--r;
			continue;
		}
		
		swap(matrix[i], matrix[r]);
		double div = matrix[r][lead];
		for (int j = lead; j <= cols; ++j) matrix[r][j] /= div;
		
		for (i = 0; i < rows; ++i) {
			if (i != r) {
				double factor = matrix[i][lead];
				for (int j = lead; j <= cols; ++j)
				matrix[i][j] -= factor * matrix[r][j];
			}
		}
		leading_columns.push_back(lead);
		++lead;
	}
}

// Функция для проверки допустимости решения (все переменные >= 0)
bool is_feasible(const vector<double>& solution) {
	for (double x : solution) {
		if (x < -EPS) return false;
	}
	return true;
}

// Целевая функция (сумма свободных членов)
double objective_function(const vector<double>& solution) {
	double sum = 0.0;
	for (double x : solution) sum += x;
	return sum;
}

// Функция для проверки, является ли базис допустимым
bool is_valid_basis(const vector<int>& basis, const vector<int>& leading_columns) {
	// Проверяем, что все ведущие столбцы находятся в пределах базиса
	for (int lc : leading_columns) {
		if (lc >= basis.size()) return false;
	}
	return true;
}

// Функция для вывода решения с учетом переставленных столбцов
void print_solution(const vector<vector<double>>& matrix, const vector<int>& basis, const vector<double>& solution) {
	cout << "Базисные переменные: ";
	for (int b : basis) cout << "x" << b + 1 << " ";
	cout << "\nРешение:\n";
	
	// Создаем список небазисных переменных
	vector<int> non_basis;
	for (int i = 0; i < matrix[0].size() - 1; ++i) {
		if (find(basis.begin(), basis.end(), i) == basis.end()) {
			non_basis.push_back(i);
		}
	}
	
	for (size_t r = 0; r < matrix.size(); ++r) {
		int lead_col = -1;
		for (size_t c = 0; c < basis.size(); ++c) {
			if (abs(matrix[r][c] - 1.0) < EPS) {
				lead_col = c;
				break;
			}
		}
		
		if (lead_col == -1) {
			if (abs(matrix[r].back()) > EPS)
			cout << "Система несовместна\n";
			continue;
		}
		
		int actual_var = basis[lead_col];
		cout << "x" << actual_var + 1 << " = " << fixed << setprecision(2) << matrix[r].back();
		
		for (size_t c = basis.size(); c < matrix[r].size() - 1; ++c) {
			double coeff = matrix[r][c];
			if (abs(coeff) > EPS) {
				int var_index = non_basis[c - basis.size()];
				if (coeff < 0) {
					cout << " + " << fixed << setprecision(2) << -coeff << "*x" << var_index + 1;
				}
				else {
					cout << " - " << fixed << setprecision(2) << coeff << "*x" << var_index + 1;
				}
			}
		}
		cout << endl;
	}
	cout << "-------------------------\n";
}

// Функция для нахождения всех опорных планов
void find_basic_solutions(vector<vector<double>> original, int num_vars) {
	int num_eqs = original.size();
	vector<int> vars(num_vars);
	iota(vars.begin(), vars.end(), 0);
	
	vector<bool> selector(num_vars);
	fill(selector.begin(), selector.begin() + num_eqs, true);
	
	vector<vector<double>> feasible_solutions;
	int count = 0;
	
	do {
		vector<int> basis;
		for (int i = 0; i < num_vars; ++i)
		if (selector[i]) basis.push_back(i);
		if (basis.size() != num_eqs) continue;
		
		vector<vector<double>> matrix = original;
		rearrangeColumns(matrix, basis);
		
		vector<int> leading_columns;
		gauss_jordan(matrix, leading_columns);
		
		cout << "Комбинация базиса " << ++count << ":\n";
		cout << "Преобразованная матрица:\n";
		for (const auto& row : matrix) {
			for (double val : row) cout << fixed << setprecision(2) << setw(8) << val;
			cout << endl;
		}
		
		if (is_valid_basis(basis, leading_columns)) {
			vector<double> solution(num_vars, 0.0);
			for (size_t r = 0; r < matrix.size(); ++r) {
				for (size_t c = 0; c < basis.size(); ++c) {
					if (abs(matrix[r][c] - 1.0) < EPS) {
						solution[basis[c]] = matrix[r].back();
						break;
					}
				}
			}
			
			if (is_feasible(solution)) {
				feasible_solutions.push_back(solution);
				print_solution(matrix, basis, solution);
				cout << "Целевая функция: " << objective_function(solution) << "\n";
				cout << "-------------------------\n";
			}
			else {
				cout << "Решение недопустимо (есть отрицательные переменные)\n";
				cout << "-------------------------\n";
			}
		}
		else {
			cout << "Не является допустимым базисом\n";
			cout << "-------------------------\n";
		}
		
	} while (prev_permutation(selector.begin(), selector.end()));
	
	// Поиск оптимального решения
	if (!feasible_solutions.empty()) {
		auto optimal_solution = *min_element(feasible_solutions.begin(), feasible_solutions.end(),
		[](const vector<double>& a, const vector<double>& b) {
			return objective_function(a) < objective_function(b);
		});
		
		cout << "\nОптимальный опорный план:\n";
		for (double x : optimal_solution) cout << fixed << setprecision(2) << x << " ";
		cout << "\nЦелевая функция: " << objective_function(optimal_solution) << "\n";
	}
	else {
		cout << "\nДопустимые решения отсутствуют!\n";
	}
}

int main() {
	setlocale(LC_ALL, "Russian");
	vector<vector<double>> matrix = {
		{-1, 5, -4, -6, 0, 1, -9},
		{8, 1, -1, 0, 2, 3, 8},
		{4, 3, -2, 9, 1, 7, 1}
	};
	find_basic_solutions(matrix, 6);
	return 0;
}
	\end{code}
	
	
	\newpage
	
	Результаты работы алгоритма:
	
	\drawzalupa{images/task2.png}{0.9}
	
	\drawzalupa{images/task21.png}{0.9}
	
	\drawzalupa{images/task22.png}{0.9}
	
	Выводятся все базисные решения, но если они не являются опорными, то в рамках условия данной задачи их решение недопустимо. Для опорных планов выводится решение и значение целевой функции. Оптимальный опорный план выбирается по наименьшему значению целевой функции.	
	
	
	Описание программы:
	
	\begin{enumerate}
		\item{Функция gauss\_jordan:}
		\begin{itemize}
			\itemПриводит расширенную матрицу системы к упрощённому ступенчатому виду.
		\end{itemize}
		\item{Функция is\_feasible:}
		\begin{itemize}
			\itemПроверяет, является ли решение опорным планом (все переменные неотрицательны).
		\end{itemize}
		\item{Функция objective\_function:}
		\begin{itemize}
			\itemЗадаёт целевую функцию
		\end{itemize}
		\item{Функция find\_optimal\_plan:}
		\begin{itemize}
			\itemНаходит все базисные решения.
			\itemОтбирает опорные планы.
			\itemНаходит оптимальный опорный план, минимизирующий целевую функцию.
		\end{itemize}
	\end{enumerate}
	
	\chapter{Задание 3}
	
	\section{Решить систему линейных уравнений аналитически (подготовить
		тестовые данные)}
	
\[
\left\{
\begin{aligned}
	&-x_1 + 5x_2 - 4x_3 - 6x_4 + x_6 = -9 \\
	&8x_1 + x_2 - x_3 + 2x_5 + 3x_6 = 8 \\
	&4x_1 + 3x_2 - 2x_3 + 9x_4 + x_5 + 7x_6 = 1
\end{aligned}
\right.
\]

\begin{itemize}

\itemТак как n > m (переменных больше чем уравнений, то система имеет бесконечно много решений)

\itemРасширенная матрица:

\begin{center}
	{
		\[
		\begin{pmatrix}
			-1 & 5 & -4 & -6 & 0 & 1 & | & -9 \\
			8 & 1 & -1 & 0 & 2 & 3 & | & 8 \\
			4 & 3 & -2 & 9 & 1 & 7 & | & 1 \\
		\end{pmatrix}
		\]
	}
\end{center}

\itemПриведение матрицы:

\begin{enumerate}
	\item{$a_{11}$ = -1}
	
	\begin{itemize}
		\itemДелим первую строку на -1:
		
		\begin{center}
			{
				\[
				\begin{pmatrix}
					1 & -5 & 4 & 6 & 0 & -1 & | & 9 \\
					8 & 1 & -1 & 0 & 2 & 3 & | & 8 \\
					4 & 3 & -2 & 9 & 1 & 7 & | & 1 \\
				\end{pmatrix}
				\]
			}
		\end{center}
		
		\itemУмножаем первую строку на 8 и вычитаем из второй:
		
		\begin{center}
			{
				\[
				\begin{pmatrix}
					1 & -5 & 4 & 6 & 0 & -1 & | & 9 \\
					0 & 41 & -33 & -48 & 2 & 11 & | & -64 \\
					4 & 3 & -2 & 9 & 1 & 7 & | & 1 \\
				\end{pmatrix}
				\]
			}
		\end{center}
		
		\itemУмножаем первую строку на 4 и вычитаем из третьей:
		
		\begin{center}
			{
				\[
				\begin{pmatrix}
					1 & -5 & 4 & 6 & 0 & -1 & | & 9 \\
					0 & 41 & -33 & -48 & 2 & 11 & | & -64 \\
					0 & 23 & -18 & -15 & 1 & 11 & | & -35 \\
				\end{pmatrix}
				\]
			}
		\end{center}
		
		\end{itemize}
		
		\newpage
		
		\item{$a_{22}$ = 41}
		
		\begin{itemize}
			\itemДелим вторую строку на 41:
			
			\begin{center}
				\Large{
					\[
					\begin{pmatrix}
						1 & -5 & 4 & 6 & 0 & -1 & | & 9 \\
						0 & 1 & -\frac{33}{41} & -\frac{48}{41} & \frac{2}{41} & \frac{11}{41} & | & -\frac{64}{41} \\
						0 & 23 & -18 & -15 & 1 & 11 & | & -35 \\
					\end{pmatrix}
					\]
				}
			\end{center}
			
			\itemУмножаем вторую строку на -5 и вычитаем из первой:
			
			\begin{center}
				\Large{
					\[
					\begin{pmatrix}
						1 & 0 & -\frac{1}{41} & \frac{6}{41} & \frac{10}{41} & \frac{14}{41} & | & \frac{49}{41} \\
						0 & 1 & -\frac{33}{41} & -\frac{48}{41} & \frac{2}{41} & \frac{11}{41} & | & -\frac{64}{41} \\
						0 & 23 & -18 & -15 & 1 & 11 & | & -35 \\
					\end{pmatrix}
					\]
				}
			\end{center}
			
			\itemУмножаем вторую строку на 23 и вычитаем из третьей:
			
			\begin{center}
				\Large{
					\[
					\begin{pmatrix}
						1 & 0 & -\frac{1}{41} & \frac{6}{41} & \frac{10}{41} & \frac{14}{41} & | & \frac{49}{41} \\
						0 & 1 & -\frac{33}{41} & -\frac{48}{41} & \frac{2}{41} & \frac{11}{41} & | & -\frac{64}{41} \\
						0 & 0 & \frac{21}{41} & \frac{489}{41} & -\frac{5}{41} & \frac{198}{41} & | & \frac{37}{41} \\
					\end{pmatrix}
					\]
				}
			\end{center}
			
			
			
			
		\end{itemize}
		
	\item{$a_{33}=\frac{21}{41}$}
	
	\begin{itemize}
		
		\itemДелим третью строку на $\frac{21}{41}$:
		
		\begin{center}
			\Large{
				\[
				\begin{pmatrix}
					1 & 0 & -\frac{1}{41} & \frac{6}{41} & \frac{10}{41} & \frac{14}{41} & | & \frac{49}{41} \\
					0 & 1 & -\frac{33}{41} & -\frac{48}{41} & \frac{2}{41} & \frac{11}{41} & | & -\frac{64}{41} \\
					0 & 0 & 1 & \frac{163}{7} & -\frac{5}{21} & \frac{66}{7} & | & \frac{37}{21} \\
				\end{pmatrix}
				\]
			}
		\end{center}
		
		\itemУмножаем третью строку на $-\frac{33}{41}$ и вычитаем из второй:
		
		\begin{center}
			\Large{
				\[
				\begin{pmatrix}
					1 & 0 & -\frac{1}{41} & \frac{6}{41} & \frac{10}{41} & \frac{14}{41} & | & \frac{49}{41} \\
					0 & 1 & 0 & -\frac{123}{7} & -\frac{1}{7} & \frac{55}{7} & | & -\frac{1}{7} \\
					0 & 0 & 1 & \frac{163}{7} & -\frac{5}{21} & \frac{66}{7} & | & \frac{37}{21} \\
				\end{pmatrix}
				\]
			}
		\end{center}
		
		\itemУмножаем третью строку на $-\frac{1}{41}$ и вычитаем из первой:
		
		\begin{center}
			\Large{
				\[
				\begin{pmatrix}
					1 & 0 & 0 & \frac{5}{7} & \frac{5}{21} & \frac{4}{7} & | & \frac{26}{21} \\
					0 & 1 & 0 & -\frac{123}{7} & -\frac{1}{7} & \frac{55}{7} & | & -\frac{1}{7} \\
					0 & 0 & 1 & \frac{163}{7} & -\frac{5}{21} & \frac{66}{7} & | & \frac{37}{21} \\
				\end{pmatrix}
				\]
			}
		\end{center}
			 
	\end{itemize}
	
	\end{enumerate}
	
	\newpage
	
	\itemМатрица в упрощенном ступенчатом виде:
	
	
	\begin{center}
		\Large{
			\[
			\begin{pmatrix}
				1 & 0 & 0 & \frac{5}{7} & \frac{5}{21} & \frac{4}{7} & | & \frac{26}{21} \\
				0 & 1 & 0 & -\frac{123}{7} & -\frac{1}{7} & \frac{55}{7} & | & -\frac{1}{7} \\
				0 & 0 & 1 & \frac{163}{7} & -\frac{5}{21} & \frac{66}{7} & | & \frac{37}{21} \\
			\end{pmatrix}
			\]
		}
	\end{center}
	
	\itemПосле всех преобразований матрица имеет вид:
	
	\begin{center}
		\Large{
			\[
			\begin{pmatrix}
				1 & 0 & 0 & a_{14} & a_{15} & a_{16} & | & b_{1} \\
				0 & 1 & 0 & a_{24} & a_{25} & a_{26} & | & b_{3} \\
				0 & 0 & 1 & a_{34} & a_{35} & a_{36} & | & b_{2} \\
			\end{pmatrix}
			\]
		}
	\end{center}
	
	
	\itemБазисные переменные: $x_1, x_2, x_3$. Выражаем их через свободные $x_4, x_5, x_6$:
	
	\[
	\left\{
	\begin{aligned}
		&x_1 = b_1 - a_{14}x_4 - a_{15}x_5 - a_{16}x_6 \\
		&x_2 = b_2 - a_{24}x_4 - a_{25}x_5 - a_{26}x_6 \\
		&x_3 = b_3 - a_{34}x_4 - a_{35}x_5 - a_{36}x_6
	\end{aligned}
	\right.
	\]
	
	
	\itemИтоговое решение:
	
	\[
	\left\{
	\begin{aligned}
		&x_1 = \frac{26}{21} - \frac{5}{7}x_4 - \frac{5}{21}x_5 - \frac{4}{7}x_6 \\
		&x_2 = -\frac{1}{7} - \frac{123}{7}x_4 + \frac{1}{7}x_5 - \frac{55}{7}x_6 \\
		&x_3 = \frac{37}{21} - \frac{163}{7}x_4 + \frac{5}{21}x_5 - \frac{66}{7}x_6
	\end{aligned}
	\right.
	\]
		
\end{itemize}

\newpage

Найдем один из опорных планов (Всего их $C_6^3$ = 20):

\begin{itemize}
	\itemДля базисных переменных $x_1, x_2, x_4$
	
	\itemРасширенная матрица:
	
	\begin{center}
		{
			\[
			\begin{pmatrix}
				-1 & 5 & -6 & -4 & 0 & 1 & | & -9 \\
				8 & 1 & 0 & -1 & 2 & 3 & | & 8 \\
				4 & 3 & 9 & -2 & 1 & 7 & | & 1 \\
			\end{pmatrix}
			\]
		}
	\end{center}
	
	\begin{enumerate}
		\item{$a_{11}$ = -1}
		
		\begin{itemize}
			\itemДелим первую строку на -1:
			
			\begin{center}
				{
					\[
					\begin{pmatrix}
						1 & -5 & 6 & 4 & 0 & -1 & | & 9 \\
						8 & 1 & 0 & -1 & 2 & 3 & | & 8 \\
						4 & 3 & 9 & -2 & 1 & 7 & | & 1 \\
					\end{pmatrix}
					\]
				}
			\end{center}
			
			\itemУмножаем первую строку на 8 и вычитаем из второй:
			
			\begin{center}
				{
					\[
					\begin{pmatrix}
						1 & -5 & 6 & 4 & 0 & -1 & | & 9 \\
						0 & 41 & -48 & -33 & 2 & 11 & | & -64 \\
						4 & 3 & 9 & -2 & 1 & 7 & | & 1 \\
					\end{pmatrix}
					\]
				}
			\end{center}
			
			\itemУмножаем первую строку на 4 и вычитаем из третьей:
			
			\begin{center}
				{
					\[
					\begin{pmatrix}
						1 & -5 & 6 & 4 & 0 & -1 & | & 9 \\
						0 & 41 & -48 & -33 & 2 & 11 & | & -64 \\
						0 & 23 & -15 & -18 & 1 & 11 & | & -35 \\
					\end{pmatrix}
					\]
				}
			\end{center}
			
		\end{itemize}
		
		
		\item{$a_{22}$ = 41}
		
		\begin{itemize}
			\itemДелим вторую строку на 41:
			
			\begin{center}
				\Large{
					\[
					\begin{pmatrix}
						1 & -5 & 6 & 4 & 0 & -1 & | & 9 \\
						0 & 1 & -\frac{48}{41} & -\frac{33}{41} & \frac{2}{41} & \frac{11}{41} & | & -\frac{64}{41} \\
						0 & 23 & -15 & -18 & 1 & 11 & | & -35 \\
					\end{pmatrix}
					\]
				}
			\end{center}
			
			\itemУмножаем вторую строку на -5 и вычитаем из первой:
			
			\begin{center}
				\Large{
					\[
					\begin{pmatrix}
						1 & 0 & \frac{6}{41} & -\frac{1}{41} & \frac{10}{41} & \frac{14}{41} & | & \frac{49}{41} \\
						0 & 1 & -\frac{48}{41} & -\frac{33}{41} & \frac{2}{41} & \frac{11}{41} & | & -\frac{64}{41} \\
						0 & 23 & -15 & -18 & 1 & 11 & | & -35 \\
					\end{pmatrix}
					\]
				}
			\end{center}
			
			\itemУмножаем вторую строку на 23 и вычитаем из третьей:
			
			\begin{center}
				\Large{
					\[
					\begin{pmatrix}
						1 & 0 & \frac{6}{41} & -\frac{1}{41} & \frac{10}{41} & \frac{14}{41} & | & \frac{49}{41} \\
						0 & 1 & -\frac{48}{41} & -\frac{33}{41} & \frac{2}{41} & \frac{11}{41} & | & -\frac{64}{41} \\
						0 & 0 & \frac{489}{41} & \frac{21}{41} & -\frac{5}{41} & \frac{198}{41} & | & \frac{37}{41} \\
					\end{pmatrix}
					\]
				}
			\end{center}
		\end{itemize}
				\item{$a_{33}=\frac{21}{41}$}
				
			
			\begin{itemize}
				
				\itemДелим третью строку на $\frac{489}{41}$:
				
				\begin{center}
					\Large{
						\[
						\begin{pmatrix}
							1 & 0 & \frac{6}{41} & -\frac{1}{41} & \frac{10}{41} & \frac{14}{41} & | & \frac{49}{41} \\
							0 & 1 & -\frac{48}{41} & -\frac{33}{41} & \frac{2}{41} & \frac{11}{41} & | & -\frac{64}{41} \\
							0 & 0 & 1 & \frac{7}{163} & -\frac{5}{489} & \frac{66}{163} & | & \frac{37}{489} \\
						\end{pmatrix}
						\]
					}
				\end{center}
				
				\itemУмножаем третью строку на $-\frac{48}{41}$ и вычитаем из второй:
				
								\begin{center}
					\Large{
						\[
						\begin{pmatrix}
							1 & 0 & \frac{6}{41} & -\frac{1}{41} & \frac{10}{41} & \frac{14}{41} & | & \frac{49}{41} \\
							0 & 1 & 0 & -\frac{123}{163} & \frac{6}{163} & \frac{121}{163} & | & \frac{240}{163} \\
							0 & 0 & 1 & \frac{7}{163} & -\frac{5}{489} & \frac{66}{163} & | & \frac{37}{489} \\
						\end{pmatrix}
						\]
					}
				\end{center}
				
				\itemУмножаем третью строку на $-\frac{6}{41}$ и вычитаем из первой:
				
				
\begin{center}
	\Large{
		\[
		\begin{pmatrix}
			1 & 0 & 0 & \frac{1020}{6683} & -\frac{173}{6683} & \frac{2678}{6683} & | & \frac{8061}{6683} \\
			0 & 1 & 0 & -\frac{123}{163} & \frac{6}{163} & \frac{121}{163} & | & \frac{240}{163} \\
			0 & 0 & 1 & \frac{7}{163} & -\frac{5}{489} & \frac{66}{163} & | & \frac{37}{489} \\
		\end{pmatrix}
		\]
	}
\end{center}
				
			\end{itemize}
			\end{enumerate}

				\itemПосле всех преобразований матрица имеет вид:
			
			\begin{center}
				\Large{
					\[
					\begin{pmatrix}
						1 & 0 & 0 & a_{14} & a_{15} & a_{16} & | & b_{1} \\
						0 & 1 & 0 & a_{24} & a_{25} & a_{26} & | & b_{3} \\
						0 & 0 & 1 & a_{34} & a_{35} & a_{36} & | & b_{2} \\
					\end{pmatrix}
					\]
				}
			\end{center}
			
			
			\itemБазисные переменные: $x_1, x_2, x_3$. Выражаем их через свободные $x_4, x_5, x_6$:
			
			\[
			\left\{
			\begin{aligned}
				&x_1 = b_1 - a_{14}x_4 - a_{15}x_5 - a_{16}x_6 \\
				&x_2 = b_2 - a_{24}x_4 - a_{25}x_5 - a_{26}x_6 \\
				&x_3 = b_3 - a_{34}x_4 - a_{35}x_5 - a_{36}x_6
			\end{aligned}
			\right.
			\]
			
			
			\itemИтоговое решение:
			
			\[
			\left\{
			\begin{aligned}
				&x_1 = \frac{8061}{6683} - \frac{1020}{6683}x_4 + \frac{173}{6683}x_5 - \frac{2678}{6683}x_6 \\
				&x_2 = \frac{240}{163} + \frac{123}{163}x_4 - \frac{6}{163}x_5 - \frac{121}{163}x_6 \\
				&x_3 = \frac{37}{489} - \frac{7}{163}x_4 + \frac{5}{489}x_5 - \frac{66}{163}x_6
			\end{aligned}
			\right.
			\]

		

\end{itemize}

	
	
	
	





	\textbf{Вывод: }в ходе выполнения лабораторной работы я составил программу для отыскания всех базисных решений системы уравнений с помощью метода Гаусса-Жордана, вывод которой совпал с  ответом в моем аналитическом решении.
\end{document}

