\documentclass{report}

\usepackage[russian]{babel}
\usepackage{geometry}
\usepackage{minted}
\usepackage[hidelinks]{hyperref}
\usepackage{xcolor}
\usepackage{xspace}
\usepackage{fancyhdr}
\usepackage{tocloft}
\usepackage{booktabs}
\usepackage{tikz}
\usepackage{titlesec}
\usepackage{tabularx}
\usepackage{setspace}
\usepackage{makecell}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{amsmath}
\usepackage{multirow}

\usetikzlibrary{shapes, arrows}
\usetikzlibrary{positioning}
\usetikzlibrary{shapes.geometric}
\usetikzlibrary{shapes.misc}
\usetikzlibrary{calc}
\usetikzlibrary{chains}

\tikzstyle{pf}=[circle, draw, text centered, minimum height = 2em]
\tikzstyle{con} = [draw, -latex']

\setcounter{MaxMatrixCols}{20}

\newcommand{\drawzalupa}[2]{
	\begin{figure}[H]
		%\begin{center}
		\centering
		\includegraphics[width=#2\textwidth]{#1}
		%\end{center}
	\end{figure}
}

\setlength{\cftaftertoctitleskip}{2pt}

\renewcommand{\cfttoctitlefont}{\LARGE\bfseries}

\titleformat{\chapter}{\normalfont\LARGE\bfseries}{\thechapter}{20pt}{\LARGE\bfseries}
\titlespacing*{\chapter}{0pt}{0pt}{20pt}

\pagestyle{fancy}

\fancyhf{} 

\fancyfoot[C]{\thepage} 

\renewcommand{\headrulewidth}{0pt} 

\renewcommand{\footrulewidth}{0pt}


\definecolor{pybg}{rgb}{0.95,0.95,0.95}


\geometry{left=3cm}
\geometry{right=1.5cm}
\geometry{top=2cm}
\geometry{bottom=2cm}

\counterwithout{figure}{chapter}


\newminted[code]{cpp}{
	bgcolor=pybg,
	baselinestretch=1.2,
	fontsize=\normalsize,
	tabsize=0,
	linenos,
	obeytabs=true,
	tabsize=4
}

\newcommand{\q}[1]{``#1''}

\begin{document}
	\begin{titlepage}
		\begin{center}
			МИНИСТЕРСТВО НАУКИ И ВЫСШЕГО ОБРАЗОВАНИЯ\linebreak 
			РОССИЙСКОЙ ФЕДЕРАЦИИ\medskip
			
			ФЕДЕРАЛЬНОЕ ГОСУДАРСТВЕННОЕ БЮДЖЕТНОЕ ОБРАЗОВАТЕЛЬНОЕ 
			УЧРЕЖДЕНИЕ ВЫСШЕГО ОБРАЗОВАНИЯ\medskip
			
			\textbf{
				«БЕЛГОРОДСКИЙ ГОСУДАРСТВЕННЫЙ \linebreak
				ТЕХНОЛОГИЧЕСКИЙ УНИВЕРСИТЕТ им. В. Г. ШУХОВА»\linebreak
				(БГТУ им. В.Г. Шухова)
			}\bigskip
			
			Кафедра программного обеспечения вычислительной техники и автоматизированных систем
			\vspace{5cm}
			
			\Large\textbf{Лабораторная работа №1}
			
			\large по дисциплине: Исследование операций\linebreak
			тема: \q{Исследование множества опорных планов системы ограничений
				задачи линейного программирования (задачи ЛП) в канонической
				форме}
		\end{center}\vspace{6cm}
		
		\begin{flushright}
			\begin{minipage}{7cm}
				Выполнил: ст. группы ПВ-231\\
				Столяров Захар\\
				\\
				Проверил: \\
				Вирченко Юрий Петрович\\
			\end{minipage}
		\end{flushright}\bigskip
		
		\
		
		\
		
		\
		
		\
		
		
		\begin{center}
			Белгород, 2025 г.
		\end{center}
	\end{titlepage}
	
	\newpage
	
	\setcounter{secnumdepth}{-1}
	\chapter{Лабораторная работа №1 <<Исследование множества опорных планов системы ограничений
		задачи линейного программирования (задачи ЛП) в канонической
		форме.>>}
	
	\textbf{Цель работы:} изучить метод Гаусса-Жордана и операцию
	замещения, а также освоить их применение к отысканию множества
	допустимых базисных видов системы линейных уравнений, и решению
	задачи линейного программирования простым перебором опорных
	решений.
	\begin{center}
		\textbf{Вариант 14}
	\end{center}
	\bigbreak
	\tableofcontents
	
	\chapter{Система уравнений моего варианта}
	
	\[
	\Large\left\{
	\begin{aligned}
		&-x_1 + 5x_2 - 4x_3 - 6x_4 + x_6 = -9 \\
		&8x_1 + x_2 - x_3 + 2x_5 + 3x_6 = 8 \\
		&4x_1 + 3x_2 - 2x_3 + 9x_4 + x_5 + 7x_6 = 1
	\end{aligned}
	\right.
	\]
	
	
	
	\chapter{Задание 1}
	\section{Составить программу для отыскания всех базисных видов системы
		линейных уравнений:}
	
	\section{Блок-схема функции gauss\_jordan}
	
	\drawzalupa{images/block1.png}{0.61}
	
	\newpage
	
	\drawzalupa{images/block2.png}{0.9}
	
	\newpage
	
	\drawzalupa{images/block3.png}{0.9}
	
	\section{Код программы}
	
	\begin{code}
		#include <iostream>
		#include <vector>
		#include <cmath>
		#include <algorithm>
		#include <numeric>
		
		using namespace std;
		
		const double EPS = 1e-9; // Точность для сравнения чисел с плавающей точкой
		
		// Функция приведения матрицы к ступенчато-улучшенной форме методом Гаусса-Жордана
		void gauss_jordan(vector<vector<double>>& matrix) {
			int rows = matrix.size();    // Количество уравнений
			int cols = matrix[0].size(); // Количество столбцов (переменные + свободные члены)
			int lead = 0; // Текущий ведущий столбец
			
			// Поочередная обработка каждой строки
			for (int r = 0; r < rows; r++) {
				if (lead >= cols) break; // Выход, если все столбцы обработаны
				
				// Поиск ненулевого элемента в текущем столбце
				int i = r;
				while (i < rows && abs(matrix[i][lead]) < EPS) i++;
				if (i == rows) { // Если столбец нулевой, переходим к следующему
					lead++;
					r--;
					continue;
				}
				
				swap(matrix[i], matrix[r]); // Перемещаем строку с ненулевым элементом наверх
				
				// Нормировка строки по ведущему элементу
				double lv = matrix[r][lead];
				for (int j = 0; j < cols; j++) {
					matrix[r][j] /= lv;
				}
				
				// Обнуление элементов текущего столбца в других строках
				for (int i = 0; i < rows; i++) {
					if (i != r) {
						double factor = matrix[i][lead];
						for (int j = 0; j < cols; j++) {
							matrix[i][j] -= factor * matrix[r][j];
						}
					}
				}
				lead++; // Переход к следующему столбцу
			}
		}
		
		// Функция вывода решения системы в зависимости от базиса
		void print_solution(const vector<vector<double>>& matrix, const vector<int>& basis) {
			int rows = matrix.size();
			int cols = matrix[0].size();
			
			// Вывод информации о базисных переменных
			cout << "Базисные переменные: ";
			for (int b : basis) cout << "x" << b + 1 << " ";
			cout << "\nРешение:\n";
			
			// Определение свободных переменных (не входящих в базис)
			vector<bool> is_free(cols - 1, true);
			for (int b : basis) is_free[b] = false;
			
			bool contradiction = false;
			
			// Построение уравнений для базисных переменных
			for (int r = 0; r < rows; r++) {
				int lead_col = -1;
				// Поиск ведущего элемента (1 в ступенчатом виде)
				for (int c = 0; c < cols - 1; c++) {
					if (abs(matrix[r][c] - 1.0) < EPS) {
						lead_col = c;
						break;
					}
				}
				
				if (lead_col == -1) { // Случай нулевой строки
					if (abs(matrix[r][cols - 1]) > EPS) {
						cout << "Нет решений (противоречие)\n";
						contradiction = true;
					}
					continue;
				}
				
				// Формирование уравнения для базисной переменной
				cout << "x" << lead_col + 1 << " = " << matrix[r][cols - 1];
				// Добавление свободных переменных в уравнение
				for (int c = 0; c < cols - 1; c++) {
					if (c != lead_col && is_free[c] && abs(matrix[r][c]) > EPS) {
						cout << " - (" << matrix[r][c] << ")*x" << c + 1;
					}
				}
				cout << endl;
			}
			if (!contradiction) cout << "-------------------------" << endl;
		}
		
		// Функция перебора всех возможных базисных решений
		void find_basic_solutions(vector<vector<double>> matrix, int num_vars) {
			int num_eqs = matrix.size(); // Количество уравнений
			vector<int> vars(num_vars);
			iota(vars.begin(), vars.end(), 0); // Заполнение 0,1,2,...,num_vars-1
			
			// Генерация сочетаний для выбора базисных переменных
			vector<bool> selector(num_vars);
			fill(selector.begin(), selector.begin() + num_eqs, true);
			
			do {
				// Формирование текущего базиса
				vector<int> basis;
				for (int i = 0; i < num_vars; i++) {
					if (selector[i]) basis.push_back(i);
				}
				
				// Копирование исходной матрицы для сохранения исходных данных
				auto temp_matrix = matrix;
				
				// Применение метода Гаусса-Жордана
				gauss_jordan(temp_matrix);
				print_solution(temp_matrix, basis);
				
			} while (prev_permutation(selector.begin(), selector.end())); // Перебор всех сочетаний
		}
		
		int main() {
			setlocale(LC_ALL, "Russian");
			// Исходная расширенная матрица системы:
			// Каждая строка имеет вид [коэффициенты | свободный член]
			vector<vector<double>> matrix = {
				{-1, 5, -4, -6, 0, 1, -9},
				{8, 1, -1, 0, 2, 3, 8},
				{4, 3, -2, 9, 1, 7, 1}
			};
			// Поиск всех базисных решений для системы с 6 переменными
			find_basic_solutions(matrix, 6);
			return 0;
		}
	\end{code}
	
	\newpage
	
	Результат работы программы:
	
	\drawzalupa{images/task1.png}{0.9}
	
	\drawzalupa{images/task12.png}{0.75}
	
	\newpage
	
	Описание программы:
	\begin{enumerate}
		\item{Ввод данных:}
		
		\begin{itemize}
			\itemПрограмма запрашивает количество уравнений и переменных.
			
			\itemЗатем вводятся коэффициенты системы уравнений.
		\end{itemize}
		
		\item{Метод Гаусса-Жордана:}
		
		\begin{itemize}
			\itemМатрица приводится к приведённому ступенчатому виду.
			
			\itemВедущие элементы (первые ненулевые элементы в строках) становятся равными 1.
			
			\itemВсе остальные элементы в столбцах ведущих элементов обнуляются.
		\end{itemize}
		
		\item{Анализ решения:}
		
		\begin{itemize}
			\itemЕсли в процессе преобразований обнаруживается строка вида 0 0 ... 0 | b, где b != 0, система не имеет решений.
			
			\itemЕсли система имеет бесконечно много решений, программа указывает свободные переменные.
			
			\itemЕсли система имеет единственное решение, программа выводит его.
		\end{itemize}
		
	\end{enumerate}
	\chapter{Задание 2}
	\section{Организовать отбор опорных планов среди всех базисных решений,
		а также нахождение оптимального опорного плана методом
		прямого перебора. Целевая функция выбирается произвольно.}
	
	Код программы:
	
	\begin{code}
		#include <iostream>
		#include <vector>
		#include <algorithm>
		#include <limits>
		#include <cmath>
		#include <iomanip>
		
		using namespace std;
		
		const double EPS = 1e-9;
		
		void gauss_jordan(vector<vector<double>>& matrix) {
			int rows = matrix.size(); 
			int cols = matrix[0].size();
			
			for (int r = 0; r < rows; r++) {
				if (abs(matrix[r][r]) < EPS) {
					for (int i = r + 1; i < rows; i++) {
						if (abs(matrix[i][r]) > EPS) {
							swap(matrix[r], matrix[i]); 
							break;
						}
					}
				}
				
				if (abs(matrix[r][r]) > EPS) {
					double div = matrix[r][r]; 
					for (int j = r; j < cols; j++) {
						matrix[r][j] /= div;
					}
				}
				
				for (int i = 0; i < rows; i++) {
					if (i != r && abs(matrix[i][r]) > EPS) {
						double mult = matrix[i][r]; 
						for (int j = r; j < cols; j++) {
							matrix[i][j] -= mult * matrix[r][j];
						}
					}
				}
			}
		}
		
		// Функция для проверки, является ли решение допустимым (все переменные >= 0)
		bool is_feasible(const vector<double>& solution) {
			for (double x : solution) {
				if (x < -EPS) return false; // Если переменная отрицательная, решение недопустимо
			}
			return true;
		}
		
		// Пример целевой функции (можно заменить на любую другую)
		double objective_function(const vector<double>& solution) {
			// Пример: 3x1 + 2x2 - 5x3 + 4x4 - x5
			return 3 * solution[0] + 2 * solution[1] - 5 * solution[2] + 4 * solution[3] - solution[4];
		}
		
		// Функция для форматированного вывода чисел с подавлением шума
		void print_number(double num) {
			if (abs(num) < 1e-7) num = 0.0; // Обнуляем малые значения
			cout << fixed << setprecision(4) << num << " "; // Выводим с точностью до 4 знаков
		}
		
		// Основная функция для поиска и вывода всех опорных планов и оптимального решения
		void find_optimal_plan(vector<vector<double>>& matrix) {
			int rows = matrix.size();    // Количество строк в матрице
			int cols = matrix[0].size(); // Количество столбцов в матрице
			
			// Приводим матрицу к ступенчато-улучшенной форме
			gauss_jordan(matrix);
			
			// Определяем базисные и свободные переменные
			vector<int> basic_vars, free_vars;
			for (int r = 0; r < rows; r++) {
				for (int c = 0; c < cols - 1; c++) {
					if (abs(matrix[r][c] - 1.0) < EPS) {
						bool is_basic = true;
						// Проверяем, является ли переменная базисной
						for (int i = 0; i < rows; i++) {
							if (i != r && abs(matrix[i][c]) > EPS) {
								is_basic = false;
								break;
							}
						}
						if (is_basic) {
							basic_vars.push_back(c); // Добавляем индекс базисной переменной
							break;
						}
					}
				}
			}
			
			// Определяем свободные переменные (не входящие в базис)
			for (int c = 0; c < cols - 1; c++) {
				if (find(basic_vars.begin(), basic_vars.end(), c) == basic_vars.end()) {
					free_vars.push_back(c); // Добавляем индекс свободной переменной
				}
			}
			
			// Генерация всех возможных базисных решений
			vector<vector<double>> all_solutions;
			for (int i = 0; i < (1 << free_vars.size()); i++) {
				vector<double> solution(cols - 1, 0.0); // Инициализируем решение нулями
				// Устанавливаем значения свободных переменных (0 или 1)
				for (int j = 0; j < free_vars.size(); j++) {
					solution[free_vars[j]] = (i & (1 << j)) ? 1.0 : 0.0;
				}
				
				// Вычисляем значения базисных переменных
				for (int r = 0; r < rows; r++) {
					for (int c : basic_vars) {
						if (abs(matrix[r][c] - 1.0) < EPS) {
							solution[c] = matrix[r][cols - 1]; // Значение из правой части
							for (int f : free_vars) {
								solution[c] -= matrix[r][f] * solution[f]; 
							}
							break;
						}
					}
				}
				all_solutions.push_back(solution); // Добавляем решение в список
			}
			
			// Отбор допустимых решений (все переменные >= 0)
			vector<vector<double>> feasible_solutions;
			for (const auto& sol : all_solutions) {
				if (is_feasible(sol)) {
					feasible_solutions.push_back(sol); // Добавляем допустимое решение
				}
			}
			
			// Вывод всех опорных планов
			cout << "Все опорные планы:\n";
			for (size_t i = 0; i < feasible_solutions.size(); ++i) {
				cout << "План " << i + 1 << ": ";
				for (double x : feasible_solutions[i]) {
					print_number(x); // Выводим значения переменных
				}
				double obj_val = objective_function(feasible_solutions[i]);
				cout << "\tЦФ: " << obj_val << "\n"; // Выводим значение целевой функции
			}
			
			// Проверка наличия допустимых решений
			if (feasible_solutions.empty()) {
				cout << "\nДопустимые решения отсутствуют!\n";
				return;
			}
			
			// Поиск оптимального решения (с минимальным значением целевой функции)
			double min_value = numeric_limits<double>::max(); // Инициализируем минимальное значение
			vector<double> optimal_solution;
			for (const auto& sol : feasible_solutions) {
				double current = objective_function(sol); 
				if (current < min_value) {
					min_value = current; // Обновляем минимальное значение
					optimal_solution = sol; // Запоминаем оптимальное решение
				}
			}
			
			// Вывод оптимального решения
			cout << "\nОптимальный опорный план:\n";
			for (double x : optimal_solution) {
				print_number(x); // Выводим значения переменных
			}
			cout << "\nЗначение целевой функции: " << min_value << "\n"; 
		}
		
		int main() {
			setlocale(LC_ALL, "Russian"); 
			
			// Расширенная матрица системы уравнений
			vector<vector<double>> matrix = {
				{-1, 5, -4, -6, 0, 1, -9},
				{8, 1, -1, 0, 2, 3, 8},
				{4, 3, -2, 9, 1, 7, 1}
			};
			
			// Поиск и вывод всех опорных планов и оптимального решения
			find_optimal_plan(matrix);
			
			return 0;
		}
	\end{code}
	
	Результаты работы алгоритма:
	
	\drawzalupa{images/task2.png}{1}
	
	\newpage
	
	Описание программы:
	
	\begin{enumerate}
		\item{Функция gauss\_jordan:}
		\begin{itemize}
			\itemПриводит расширенную матрицу системы к упрощённому ступенчатому виду.
		\end{itemize}
		\item{Функция is\_feasible:}
		\begin{itemize}
			\itemПроверяет, является ли решение опорным планом (все переменные неотрицательны).
		\end{itemize}
		\item{Функция objective\_function:}
		\begin{itemize}
			\itemЗадаёт целевую функцию
		\end{itemize}
		\item{Функция find\_optimal\_plan:}
		\begin{itemize}
			\itemНаходит все базисные решения.
			\itemОтбирает опорные планы.
			\itemНаходит оптимальный опорный план, минимизирующий целевую функцию.
		\end{itemize}
	\end{enumerate}
	
	\chapter{Задание 3}
	
	\section{Решить систему линейных уравнений вручную (подготовить
		тестовые данные)}
	
	\[
	\left\{
	\begin{aligned}
		&-x_1 + 5x_2 - 4x_3 - 6x_4 + x_6 = -9 \\
		&8x_1 + x_2 - x_3 + 2x_5 + 3x_6 = 8 \\
		&4x_1 + 3x_2 - 2x_3 + 9x_4 + x_5 + 7x_6 = 1
	\end{aligned}
	\right.
	\]
	
	\begin{itemize}
		
		\itemТак как n > m (переменных больше чем уравнений, то система имеет бесконечно много решений)
		
		\itemРасширенная матрица:
		
		\begin{center}
			{
				\[
				\begin{pmatrix}
					-1 & 5 & -4 & -6 & 0 & 1 & | & -9 \\
					8 & 1 & -1 & 0 & 2 & 3 & | & 8 \\
					4 & 3 & -2 & 9 & 1 & 7 & | & 1 \\
				\end{pmatrix}
				\]
			}
		\end{center}
		
		\itemПриведение матрицы:
		
		\begin{enumerate}
			\item{$a_{11}$ = -1}
			
			\begin{itemize}
				\itemДелим первую строку на -1:
				
				\begin{center}
					{
						\[
						\begin{pmatrix}
							1 & -5 & 4 & 6 & 0 & -1 & | & 9 \\
							8 & 1 & -1 & 0 & 2 & 3 & | & 8 \\
							4 & 3 & -2 & 9 & 1 & 7 & | & 1 \\
						\end{pmatrix}
						\]
					}
				\end{center}
				
				\itemУмножаем первую строку на 8 и вычитаем из второй:
				
				\begin{center}
					{
						\[
						\begin{pmatrix}
							1 & -5 & 4 & 6 & 0 & -1 & | & 9 \\
							0 & 41 & -33 & -48 & 2 & 11 & | & -64 \\
							4 & 3 & -2 & 9 & 1 & 7 & | & 1 \\
						\end{pmatrix}
						\]
					}
				\end{center}
				
				\itemУмножаем первую строку на 4 и вычитаем из третьей:
				
				\begin{center}
					{
						\[
						\begin{pmatrix}
							1 & -5 & 4 & 6 & 0 & -1 & | & 9 \\
							0 & 41 & -33 & -48 & 2 & 11 & | & -64 \\
							0 & 23 & -18 & -15 & 1 & 11 & | & -35 \\
						\end{pmatrix}
						\]
					}
				\end{center}
				
			\end{itemize}
			
			\newpage
			
			\item{$a_{22}$ = 41}
			
			\begin{itemize}
				\itemДелим вторую строку на 41:
				
				\begin{center}
					\Large{
						\[
						\begin{pmatrix}
							1 & -5 & 4 & 6 & 0 & -1 & | & 9 \\
							0 & 1 & -\frac{33}{41} & -\frac{48}{41} & \frac{2}{41} & \frac{11}{41} & | & -\frac{64}{41} \\
							0 & 23 & -18 & -15 & 1 & 11 & | & -35 \\
						\end{pmatrix}
						\]
					}
				\end{center}
				
				\itemУмножаем вторую строку на -5 и вычитаем из первой:
				
				\begin{center}
					\Large{
						\[
						\begin{pmatrix}
							1 & 0 & -\frac{1}{41} & \frac{6}{41} & \frac{10}{41} & \frac{14}{41} & | & \frac{49}{41} \\
							0 & 1 & -\frac{33}{41} & -\frac{48}{41} & \frac{2}{41} & \frac{11}{41} & | & -\frac{64}{41} \\
							0 & 23 & -18 & -15 & 1 & 11 & | & -35 \\
						\end{pmatrix}
						\]
					}
				\end{center}
				
				\itemУмножаем вторую строку на 23 и вычитаем из третьей:
				
				\begin{center}
					\Large{
						\[
						\begin{pmatrix}
							1 & 0 & -\frac{1}{41} & \frac{6}{41} & \frac{10}{41} & \frac{14}{41} & | & \frac{49}{41} \\
							0 & 1 & -\frac{33}{41} & -\frac{48}{41} & \frac{2}{41} & \frac{11}{41} & | & -\frac{64}{41} \\
							0 & 0 & \frac{21}{41} & \frac{489}{41} & -\frac{5}{41} & \frac{198}{41} & | & \frac{37}{41} \\
						\end{pmatrix}
						\]
					}
				\end{center}
				
				
				
				
			\end{itemize}
			
			\item{$a_{33}=\frac{21}{41}$}
			
			\begin{itemize}
				
				\itemДелим третью строку на $\frac{21}{41}$:
				
				\begin{center}
					\Large{
						\[
						\begin{pmatrix}
							1 & 0 & -\frac{1}{41} & \frac{6}{41} & \frac{10}{41} & \frac{14}{41} & | & \frac{49}{41} \\
							0 & 1 & -\frac{33}{41} & -\frac{48}{41} & \frac{2}{41} & \frac{11}{41} & | & -\frac{64}{41} \\
							0 & 0 & 1 & \frac{163}{7} & -\frac{5}{21} & \frac{66}{7} & | & \frac{37}{21} \\
						\end{pmatrix}
						\]
					}
				\end{center}
				
				\itemУмножаем третью строку на $-\frac{33}{41}$ и вычитаем из второй:
				
				\begin{center}
					\Large{
						\[
						\begin{pmatrix}
							1 & 0 & -\frac{1}{41} & \frac{6}{41} & \frac{10}{41} & \frac{14}{41} & | & \frac{49}{41} \\
							0 & 1 & 0 & -\frac{123}{7} & -\frac{1}{7} & \frac{55}{7} & | & -\frac{1}{7} \\
							0 & 0 & 1 & \frac{163}{7} & -\frac{5}{21} & \frac{66}{7} & | & \frac{37}{21} \\
						\end{pmatrix}
						\]
					}
				\end{center}
				
				\itemУмножаем третью строку на $-\frac{1}{41}$ и вычитаем из первой:
				
				\begin{center}
					\Large{
						\[
						\begin{pmatrix}
							1 & 0 & 0 & \frac{5}{7} & \frac{5}{21} & \frac{4}{7} & | & \frac{26}{21} \\
							0 & 1 & 0 & -\frac{123}{7} & -\frac{1}{7} & \frac{55}{7} & | & -\frac{1}{7} \\
							0 & 0 & 1 & \frac{163}{7} & -\frac{5}{21} & \frac{66}{7} & | & \frac{37}{21} \\
						\end{pmatrix}
						\]
					}
				\end{center}
				
			\end{itemize}
			
		\end{enumerate}
		
		\newpage
		
		\itemМатрица в упрощенном ступенчатом виде:
		
		
		\begin{center}
			\Large{
				\[
				\begin{pmatrix}
					1 & 0 & 0 & \frac{5}{7} & \frac{5}{21} & \frac{4}{7} & | & \frac{26}{21} \\
					0 & 1 & 0 & -\frac{123}{7} & -\frac{1}{7} & \frac{55}{7} & | & -\frac{1}{7} \\
					0 & 0 & 1 & \frac{163}{7} & -\frac{5}{21} & \frac{66}{7} & | & \frac{37}{21} \\
				\end{pmatrix}
				\]
			}
		\end{center}
		
		\itemПосле всех преобразований матрица имеет вид:
		
		\begin{center}
			\Large{
				\[
				\begin{pmatrix}
					1 & 0 & 0 & a_{14} & a_{15} & a_{16} & | & b_{1} \\
					0 & 1 & 0 & a_{24} & a_{25} & a_{26} & | & b_{3} \\
					0 & 0 & 1 & a_{34} & a_{35} & a_{36} & | & b_{2} \\
				\end{pmatrix}
				\]
			}
		\end{center}
		
		
		\itemБазисные переменные: $x_1, x_2, x_3$. Выражаем их через свободные $x_4, x_5, x_6$:
		
		\[
		\left\{
		\begin{aligned}
			&x_1 = b_1 - a_{14}x_4 - a_{15}x_5 - a_{16}x_6 \\
			&x_2 = b_2 - a_{24}x_4 - a_{25}x_5 - a_{26}x_6 \\
			&x_3 = b_3 - a_{34}x_4 - a_{35}x_5 - a_{36}x_6
		\end{aligned}
		\right.
		\]
		
		
		\itemИтоговое решение:
		
		\[
		\left\{
		\begin{aligned}
			&x_1 = \frac{26}{21} - \frac{5}{7}x_4 - \frac{5}{21}x_5 - \frac{4}{7}x_6 \\
			&x_2 = -\frac{1}{7} - \frac{123}{7}x_4 + \frac{1}{7}x_5 - \frac{55}{7}x_6 \\
			&x_3 = \frac{37}{21} - \frac{163}{7}x_4 + \frac{5}{21}x_5 - \frac{66}{7}x_6
		\end{aligned}
		\right.
		\]
		
	\end{itemize}
	
	\newpage
	
	Найдем один из опорных планов (Всего их $C_6^3$ = 20):
	
	\begin{itemize}
		\itemДля базисных переменных $x_1, x_2, x_4$
		
		\itemРасширенная матрица:
		
		\begin{center}
			{
				\[
				\begin{pmatrix}
					-1 & 5 & -6 & -4 & 0 & 1 & | & -9 \\
					8 & 1 & 0 & -1 & 2 & 3 & | & 8 \\
					4 & 3 & 9 & -2 & 1 & 7 & | & 1 \\
				\end{pmatrix}
				\]
			}
		\end{center}
		
		\begin{enumerate}
			\item{$a_{11}$ = -1}
			
			\begin{itemize}
				\itemДелим первую строку на -1:
				
				\begin{center}
					{
						\[
						\begin{pmatrix}
							1 & -5 & 6 & 4 & 0 & -1 & | & 9 \\
							8 & 1 & 0 & -1 & 2 & 3 & | & 8 \\
							4 & 3 & 9 & -2 & 1 & 7 & | & 1 \\
						\end{pmatrix}
						\]
					}
				\end{center}
				
				\itemУмножаем первую строку на 8 и вычитаем из второй:
				
				\begin{center}
					{
						\[
						\begin{pmatrix}
							1 & -5 & 6 & 4 & 0 & -1 & | & 9 \\
							0 & 41 & -48 & -33 & 2 & 11 & | & -64 \\
							4 & 3 & 9 & -2 & 1 & 7 & | & 1 \\
						\end{pmatrix}
						\]
					}
				\end{center}
				
				\itemУмножаем первую строку на 4 и вычитаем из третьей:
				
				\begin{center}
					{
						\[
						\begin{pmatrix}
							1 & -5 & 6 & 4 & 0 & -1 & | & 9 \\
							0 & 41 & -48 & -33 & 2 & 11 & | & -64 \\
							0 & 23 & -15 & -18 & 1 & 11 & | & -35 \\
						\end{pmatrix}
						\]
					}
				\end{center}
				
			\end{itemize}
			
			
			\item{$a_{22}$ = 41}
			
			\begin{itemize}
				\itemДелим вторую строку на 41:
				
				\begin{center}
					\Large{
						\[
						\begin{pmatrix}
							1 & -5 & 6 & 4 & 0 & -1 & | & 9 \\
							0 & 1 & -\frac{48}{41} & -\frac{33}{41} & \frac{2}{41} & \frac{11}{41} & | & -\frac{64}{41} \\
							0 & 23 & -15 & -18 & 1 & 11 & | & -35 \\
						\end{pmatrix}
						\]
					}
				\end{center}
				
				\itemУмножаем вторую строку на -5 и вычитаем из первой:
				
				\begin{center}
					\Large{
						\[
						\begin{pmatrix}
							1 & 0 & \frac{6}{41} & -\frac{1}{41} & \frac{10}{41} & \frac{14}{41} & | & \frac{49}{41} \\
							0 & 1 & -\frac{48}{41} & -\frac{33}{41} & \frac{2}{41} & \frac{11}{41} & | & -\frac{64}{41} \\
							0 & 23 & -15 & -18 & 1 & 11 & | & -35 \\
						\end{pmatrix}
						\]
					}
				\end{center}
				
				\itemУмножаем вторую строку на 23 и вычитаем из третьей:
				
				\begin{center}
					\Large{
						\[
						\begin{pmatrix}
							1 & 0 & \frac{6}{41} & -\frac{1}{41} & \frac{10}{41} & \frac{14}{41} & | & \frac{49}{41} \\
							0 & 1 & -\frac{48}{41} & -\frac{33}{41} & \frac{2}{41} & \frac{11}{41} & | & -\frac{64}{41} \\
							0 & 0 & \frac{489}{41} & \frac{21}{41} & -\frac{5}{41} & \frac{198}{41} & | & \frac{37}{41} \\
						\end{pmatrix}
						\]
					}
				\end{center}
			\end{itemize}
			\item{$a_{33}=\frac{21}{41}$}
			
			
			\begin{itemize}
				
				\itemДелим третью строку на $\frac{489}{41}$:
				
				\begin{center}
					\Large{
						\[
						\begin{pmatrix}
							1 & 0 & \frac{6}{41} & -\frac{1}{41} & \frac{10}{41} & \frac{14}{41} & | & \frac{49}{41} \\
							0 & 1 & -\frac{48}{41} & -\frac{33}{41} & \frac{2}{41} & \frac{11}{41} & | & -\frac{64}{41} \\
							0 & 0 & 1 & \frac{7}{163} & -\frac{5}{489} & \frac{66}{163} & | & \frac{37}{489} \\
						\end{pmatrix}
						\]
					}
				\end{center}
				
				\itemУмножаем третью строку на $-\frac{48}{41}$ и вычитаем из второй:
				
				\begin{center}
					\Large{
						\[
						\begin{pmatrix}
							1 & 0 & \frac{6}{41} & -\frac{1}{41} & \frac{10}{41} & \frac{14}{41} & | & \frac{49}{41} \\
							0 & 1 & 0 & -\frac{123}{163} & \frac{6}{163} & \frac{121}{163} & | & \frac{240}{163} \\
							0 & 0 & 1 & \frac{7}{163} & -\frac{5}{489} & \frac{66}{163} & | & \frac{37}{489} \\
						\end{pmatrix}
						\]
					}
				\end{center}
				
				\itemУмножаем третью строку на $-\frac{6}{41}$ и вычитаем из первой:
				
				
				\begin{center}
					\Large{
						\[
						\begin{pmatrix}
							1 & 0 & 0 & \frac{1020}{6683} & -\frac{173}{6683} & \frac{2678}{6683} & | & \frac{8061}{6683} \\
							0 & 1 & 0 & -\frac{123}{163} & \frac{6}{163} & \frac{121}{163} & | & \frac{240}{163} \\
							0 & 0 & 1 & \frac{7}{163} & -\frac{5}{489} & \frac{66}{163} & | & \frac{37}{489} \\
						\end{pmatrix}
						\]
					}
				\end{center}
				
			\end{itemize}
		\end{enumerate}
		
		\itemПосле всех преобразований матрица имеет вид:
		
		\begin{center}
			\Large{
				\[
				\begin{pmatrix}
					1 & 0 & 0 & a_{14} & a_{15} & a_{16} & | & b_{1} \\
					0 & 1 & 0 & a_{24} & a_{25} & a_{26} & | & b_{3} \\
					0 & 0 & 1 & a_{34} & a_{35} & a_{36} & | & b_{2} \\
				\end{pmatrix}
				\]
			}
		\end{center}
		
		
		\itemБазисные переменные: $x_1, x_2, x_3$. Выражаем их через свободные $x_4, x_5, x_6$:
		
		\[
		\left\{
		\begin{aligned}
			&x_1 = b_1 - a_{14}x_4 - a_{15}x_5 - a_{16}x_6 \\
			&x_2 = b_2 - a_{24}x_4 - a_{25}x_5 - a_{26}x_6 \\
			&x_3 = b_3 - a_{34}x_4 - a_{35}x_5 - a_{36}x_6
		\end{aligned}
		\right.
		\]
		
		
		\itemИтоговое решение:
		
		\[
		\left\{
		\begin{aligned}
			&x_1 = \frac{8061}{6683} - \frac{1020}{6683}x_4 + \frac{173}{6683}x_5 - \frac{2678}{6683}x_6 \\
			&x_2 = \frac{240}{163} + \frac{123}{163}x_4 - \frac{6}{163}x_5 - \frac{121}{163}x_6 \\
			&x_3 = \frac{37}{489} - \frac{7}{163}x_4 + \frac{5}{489}x_5 - \frac{66}{163}x_6
		\end{aligned}
		\right.
		\]
		Целевая функция равна сумме свободных членов:
		
		\item\Large{$\frac{8061}{41} + \frac{240}{163} + \frac{37}{489} = \frac{55220}{20049}$}
		
		
	\end{itemize}
	
	
	
	
	
	
	
	
	
	
	\textbf{Вывод: }в ходе выполнения лабораторной работы я составил программу для отыскания всех базисных решений системы уравнений с помощью метода Гаусса-Жордана, вывод которой совпал с  ответом в моем аналитическом решении.
\end{document}

