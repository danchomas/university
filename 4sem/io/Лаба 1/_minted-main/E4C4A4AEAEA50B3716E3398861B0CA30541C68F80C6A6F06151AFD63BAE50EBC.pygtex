\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{fractions}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{n}{Fraction}
\PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{itertools}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{n}{combinations}

\PYG{c+c1}{\PYGZsh{} Функция для проверки, является ли вектор нулевым}
\PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{is\PYGZus{}zero\PYGZus{}vector}\PYG{p}{(}\PYG{n}{vector}\PYG{p}{:} \PYG{n+nb}{list}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n+nb}{bool}\PYG{p}{:}
   \PYG{k}{return} \PYG{n}{vector} \PYG{o}{==} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{*} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{vector}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Функция для копирования матрицы}
\PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{clone\PYGZus{}matrix}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{:} \PYG{n+nb}{list}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n+nb}{list}\PYG{p}{:}
   \PYG{k}{return} \PYG{p}{[}\PYG{n}{row}\PYG{p}{[:]} \PYG{k}{for} \PYG{n}{row} \PYG{o+ow}{in} \PYG{n}{matrix}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Функция для вывода матрицы}
\PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{output\PYGZus{}matrix}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{:} \PYG{n+nb}{list}\PYG{p}{):}
   \PYG{k}{for} \PYG{n}{row} \PYG{o+ow}{in} \PYG{n}{matrix}\PYG{p}{:}
       \PYG{n+nb}{print}\PYG{p}{(}\PYG{o}{*}\PYG{n}{row}\PYG{p}{)}
   \PYG{n+nb}{print}\PYG{p}{()}

\PYG{c+c1}{\PYGZsh{} Функция для вычисления определителя матрицы}
\PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{determinant}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{:} \PYG{n+nb}{list}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n}{Fraction}\PYG{p}{:}
   \PYG{n}{n} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{)}

   \PYG{c+c1}{\PYGZsh{} Базовые случаи для матриц 1x1 и 2x2}
   \PYG{k}{if} \PYG{n}{n} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{:}
       \PYG{k}{return} \PYG{n}{matrix}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{][}\PYG{l+m+mi}{0}\PYG{p}{]}
   \PYG{k}{if} \PYG{n}{n} \PYG{o}{==} \PYG{l+m+mi}{2}\PYG{p}{:}
       \PYG{k}{return} \PYG{n}{matrix}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{][}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{*} \PYG{n}{matrix}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{][}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{matrix}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{][}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{*} \PYG{n}{matrix}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{][}\PYG{l+m+mi}{0}\PYG{p}{]}

   \PYG{n}{det} \PYG{o}{=} \PYG{l+m+mi}{0}

   \PYG{c+c1}{\PYGZsh{} Рекурсивное вычисление определителя для матриц большего размера}
   \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{):}
       \PYG{n}{minor} \PYG{o}{=} \PYG{p}{[}\PYG{n}{row}\PYG{p}{[:}\PYG{n}{j}\PYG{p}{]} \PYG{o}{+} \PYG{n}{row}\PYG{p}{[}\PYG{n}{j} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{:]} \PYG{k}{for} \PYG{n}{row} \PYG{o+ow}{in} \PYG{n}{matrix}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:]]}
       \PYG{n}{det} \PYG{o}{+=} \PYG{n}{matrix}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{][}\PYG{n}{j}\PYG{p}{]} \PYG{o}{*} \PYG{p}{((}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{**} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{+} \PYG{n}{j} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{))} \PYG{o}{*} \PYG{n}{determinant}\PYG{p}{(}\PYG{n}{minor}\PYG{p}{)}

   \PYG{k}{return} \PYG{n}{det}

\PYG{c+c1}{\PYGZsh{} Функция для получения столбца матрицы по индексу}
\PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{get\PYGZus{}column}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{:} \PYG{n+nb}{list}\PYG{p}{,} \PYG{n}{col\PYGZus{}index}\PYG{p}{:} \PYG{n+nb}{int}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n+nb}{list}\PYG{p}{:}
   \PYG{k}{return} \PYG{p}{[}\PYG{n}{row}\PYG{p}{[}\PYG{n}{col\PYGZus{}index}\PYG{p}{]} \PYG{k}{for} \PYG{n}{row} \PYG{o+ow}{in} \PYG{n}{matrix}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Функция для создания матрицы из выбранных столбцов}
\PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{create\PYGZus{}matrix\PYGZus{}from\PYGZus{}cols}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{:} \PYG{n+nb}{list}\PYG{p}{,} \PYG{n}{col\PYGZus{}indices}\PYG{p}{:} \PYG{n+nb}{list}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n+nb}{list}\PYG{p}{:}
   \PYG{k}{return} \PYG{p}{[}\PYG{n}{get\PYGZus{}column}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{col\PYGZus{}indices}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Функция для вычисления ранга матрицы}
\PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{matrix\PYGZus{}rank}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{:} \PYG{n+nb}{list}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n+nb}{int}\PYG{p}{:}
   \PYG{n}{rows} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{)}
   \PYG{n}{cols} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{])} \PYG{k}{if} \PYG{n}{matrix} \PYG{k}{else} \PYG{l+m+mi}{0}
   \PYG{n}{rank} \PYG{o}{=} \PYG{l+m+mi}{0}

   \PYG{c+c1}{\PYGZsh{} Перебор всех возможных подматриц для вычисления ранга}
   \PYG{k}{for} \PYG{n}{order} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{rows}\PYG{p}{,} \PYG{n}{cols}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{):}
       \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{rows} \PYG{o}{\PYGZhy{}} \PYG{n}{order} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{):}
           \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{cols} \PYG{o}{\PYGZhy{}} \PYG{n}{order} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{):}
               \PYG{n}{sub\PYGZus{}matrix} \PYG{o}{=} \PYG{p}{[}\PYG{n}{row}\PYG{p}{[}\PYG{n}{j}\PYG{p}{:}\PYG{n}{j} \PYG{o}{+} \PYG{n}{order}\PYG{p}{]} \PYG{k}{for} \PYG{n}{row} \PYG{o+ow}{in} \PYG{n}{matrix}\PYG{p}{[}\PYG{n}{i}\PYG{p}{:}\PYG{n}{i} \PYG{o}{+} \PYG{n}{order}\PYG{p}{]]}
               \PYG{n}{det} \PYG{o}{=} \PYG{n}{determinant}\PYG{p}{(}\PYG{n}{sub\PYGZus{}matrix}\PYG{p}{)}
               \PYG{k}{if} \PYG{n}{det} \PYG{o}{!=} \PYG{l+m+mi}{0}\PYG{p}{:}
                   \PYG{n}{rank} \PYG{o}{+=} \PYG{l+m+mi}{1}
                   \PYG{k}{break}
           \PYG{k}{if} \PYG{n}{det} \PYG{o}{!=} \PYG{l+m+mi}{0}\PYG{p}{:}
               \PYG{k}{break}

   \PYG{k}{return} \PYG{n}{rank}

\PYG{c+c1}{\PYGZsh{} Функция для приведения матрицы к стандартному виду (без последнего столбца)}
\PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{cut\PYGZus{}matrix\PYGZus{}to\PYGZus{}standard}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{:} \PYG{n+nb}{list}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n+nb}{list}\PYG{p}{:}
   \PYG{k}{return} \PYG{p}{[}\PYG{n}{row}\PYG{p}{[:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{k}{for} \PYG{n}{row} \PYG{o+ow}{in} \PYG{n}{clone\PYGZus{}matrix}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{)]}

\PYG{c+c1}{\PYGZsh{} Функция для выполнения метода Гаусса\PYGZhy{}Жордана}
\PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{Gauss\PYGZus{}Jordan\PYGZus{}eliminations}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{:} \PYG{n+nb}{list}\PYG{p}{,} \PYG{n}{basic\PYGZus{}var\PYGZus{}indices}\PYG{p}{:} \PYG{n+nb}{tuple}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n+nb}{list}\PYG{p}{:}
   \PYG{k}{if} \PYG{n}{matrix\PYGZus{}rank}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{)} \PYG{o}{!=} \PYG{n}{matrix\PYGZus{}rank}\PYG{p}{(}\PYG{n}{cut\PYGZus{}matrix\PYGZus{}to\PYGZus{}standard}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{)):}
       \PYG{k}{return} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}

   \PYG{n}{n} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{)}
   \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{):}
       \PYG{k}{if} \PYG{n}{is\PYGZus{}zero\PYGZus{}vector}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]):}
           \PYG{k}{continue}

       \PYG{n}{col\PYGZus{}num} \PYG{o}{=} \PYG{n}{basic\PYGZus{}var\PYGZus{}indices}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
       \PYG{n}{divisor} \PYG{o}{=} \PYG{n}{matrix}\PYG{p}{[}\PYG{n}{i}\PYG{p}{][}\PYG{n}{col\PYGZus{}num}\PYG{p}{]}

       \PYG{k}{if} \PYG{n}{divisor} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
           \PYG{n}{exchange\PYGZus{}row} \PYG{o}{=} \PYG{n}{find\PYGZus{}exchange\PYGZus{}row}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{,} \PYG{n}{i}\PYG{p}{,} \PYG{n}{col\PYGZus{}num}\PYG{p}{)}
           \PYG{k}{if} \PYG{n}{exchange\PYGZus{}row} \PYG{o+ow}{is} \PYG{k+kc}{None}\PYG{p}{:}
               \PYG{k}{return} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
           \PYG{n}{matrix}\PYG{p}{[}\PYG{n}{i}\PYG{p}{],} \PYG{n}{matrix}\PYG{p}{[}\PYG{n}{exchange\PYGZus{}row}\PYG{p}{]} \PYG{o}{=} \PYG{n}{matrix}\PYG{p}{[}\PYG{n}{exchange\PYGZus{}row}\PYG{p}{],} \PYG{n}{matrix}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
           \PYG{n}{divisor} \PYG{o}{=} \PYG{n}{matrix}\PYG{p}{[}\PYG{n}{i}\PYG{p}{][}\PYG{n}{col\PYGZus{}num}\PYG{p}{]}

       \PYG{n}{matrix}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{Fraction}\PYG{p}{(}\PYG{n}{elem}\PYG{p}{,} \PYG{n}{divisor}\PYG{p}{)} \PYG{k}{for} \PYG{n}{elem} \PYG{o+ow}{in} \PYG{n}{matrix}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]]}

       \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{)):}
           \PYG{k}{if} \PYG{n}{is\PYGZus{}zero\PYGZus{}vector}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]):}
               \PYG{k}{continue}
           \PYG{k}{if} \PYG{n}{i} \PYG{o}{!=} \PYG{n}{j}\PYG{p}{:}
               \PYG{n}{multiplier} \PYG{o}{=} \PYG{n}{matrix}\PYG{p}{[}\PYG{n}{j}\PYG{p}{][}\PYG{n}{col\PYGZus{}num}\PYG{p}{]}
               \PYG{n}{matrix}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{elem\PYGZus{}j} \PYG{o}{\PYGZhy{}} \PYG{n}{elem\PYGZus{}i} \PYG{o}{*} \PYG{n}{multiplier} \PYG{k}{for} \PYG{n}{elem\PYGZus{}i}\PYG{p}{,} \PYG{n}{elem\PYGZus{}j} \PYG{o+ow}{in} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{[}\PYG{n}{i}\PYG{p}{],} \PYG{n}{matrix}\PYG{p}{[}\PYG{n}{j}\PYG{p}{])]}

   \PYG{k}{return} \PYG{n}{matrix}

\PYG{c+c1}{\PYGZsh{} Функция для поиска строки для обмена в методе Гаусса\PYGZhy{}Жордана}
\PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{find\PYGZus{}exchange\PYGZus{}row}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{:} \PYG{n+nb}{list}\PYG{p}{,} \PYG{n}{start\PYGZus{}row}\PYG{p}{:} \PYG{n+nb}{int}\PYG{p}{,} \PYG{n}{col\PYGZus{}num}\PYG{p}{:} \PYG{n+nb}{int}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n+nb}{int}\PYG{p}{:}
   \PYG{k}{for} \PYG{n}{row} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{start\PYGZus{}row} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{)):}
       \PYG{k}{if} \PYG{n}{matrix}\PYG{p}{[}\PYG{n}{row}\PYG{p}{][}\PYG{n}{col\PYGZus{}num}\PYG{p}{]} \PYG{o}{!=} \PYG{l+m+mi}{0}\PYG{p}{:}
           \PYG{k}{return} \PYG{n}{row}
   \PYG{k}{return} \PYG{k+kc}{None}

\PYG{c+c1}{\PYGZsh{} Функция для проверки, могут ли переменные быть базисными}
\PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{could\PYGZus{}vars\PYGZus{}be\PYGZus{}basic}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{:} \PYG{n+nb}{list}\PYG{p}{,} \PYG{n}{var\PYGZus{}indices}\PYG{p}{:} \PYG{n+nb}{list}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n+nb}{bool}\PYG{p}{:}
   \PYG{n}{sub\PYGZus{}matrix} \PYG{o}{=} \PYG{n}{create\PYGZus{}matrix\PYGZus{}from\PYGZus{}cols}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{,} \PYG{n}{var\PYGZus{}indices}\PYG{p}{)}
   \PYG{n}{det} \PYG{o}{=} \PYG{n}{determinant}\PYG{p}{(}\PYG{n}{sub\PYGZus{}matrix}\PYG{p}{)}
   \PYG{k}{return} \PYG{n}{det} \PYG{o}{!=} \PYG{l+m+mi}{0}

\PYG{c+c1}{\PYGZsh{} Функция для получения всех наборов базисных переменных}
\PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{get\PYGZus{}all\PYGZus{}sets\PYGZus{}of\PYGZus{}basic\PYGZus{}vars}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{:} \PYG{n+nb}{list}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n+nb}{list}\PYG{p}{:}
   \PYG{n}{sub\PYGZus{}matrix} \PYG{o}{=} \PYG{n}{cut\PYGZus{}matrix\PYGZus{}to\PYGZus{}standard}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{)}
   \PYG{n}{amount\PYGZus{}of\PYGZus{}basic\PYGZus{}vars} \PYG{o}{=} \PYG{n}{matrix\PYGZus{}rank}\PYG{p}{(}\PYG{n}{sub\PYGZus{}matrix}\PYG{p}{)}
   \PYG{n}{all\PYGZus{}vars} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{sub\PYGZus{}matrix}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{])}

   \PYG{n}{set\PYGZus{}of\PYGZus{}basic\PYGZus{}vars} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{combinations}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{all\PYGZus{}vars}\PYG{p}{),} \PYG{n}{amount\PYGZus{}of\PYGZus{}basic\PYGZus{}vars}\PYG{p}{))}

   \PYG{c+c1}{\PYGZsh{} Фильтрация наборов базисных переменных}
   \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{set\PYGZus{}of\PYGZus{}basic\PYGZus{}vars}\PYG{p}{:}
       \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{could\PYGZus{}vars\PYGZus{}be\PYGZus{}basic}\PYG{p}{(}\PYG{n}{clone\PYGZus{}matrix}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{),} \PYG{n}{i}\PYG{p}{):}
           \PYG{k}{del} \PYG{n}{i}
   \PYG{k}{return} \PYG{n}{set\PYGZus{}of\PYGZus{}basic\PYGZus{}vars}

\PYG{c+c1}{\PYGZsh{} Функция для форматированного вывода переменных}
\PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{print\PYGZus{}vars}\PYG{p}{(}\PYG{n}{var\PYGZus{}indices}\PYG{p}{:} \PYG{n+nb}{list}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n+nb}{str}\PYG{p}{:}
   \PYG{k}{return} \PYG{l+s+s1}{\PYGZsq{}(\PYGZsq{}} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}, \PYGZsq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}x}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{var\PYGZus{}indices}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{})\PYGZsq{}}

\PYG{c+c1}{\PYGZsh{} Функция для создания строки линейного уравнения}
\PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{make\PYGZus{}linear\PYGZus{}equation}\PYG{p}{(}\PYG{n}{coefficients}\PYG{p}{:} \PYG{n+nb}{list}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n+nb}{str}\PYG{p}{:}
   \PYG{n}{equation} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}}
   \PYG{k}{for} \PYG{n}{idx}\PYG{p}{,} \PYG{n}{coeff} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{coefficients}\PYG{p}{[:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]):}
       \PYG{k}{if} \PYG{n}{coeff}\PYG{p}{:}
           \PYG{k}{if} \PYG{n}{coeff} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{:}
               \PYG{k}{if} \PYG{n}{coeff} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{:}
                   \PYG{n}{equation} \PYG{o}{+=} \PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}+ x}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{idx}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{ \PYGZsq{}}
               \PYG{k}{else}\PYG{p}{:}
                   \PYG{n}{equation} \PYG{o}{+=} \PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}+ }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{coeff}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{x}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{idx}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{ \PYGZsq{}}
           \PYG{k}{else}\PYG{p}{:}
               \PYG{k}{if} \PYG{n}{coeff} \PYG{o}{==} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{:}
                   \PYG{n}{equation} \PYG{o}{+=} \PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}\PYGZhy{}x}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{idx}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{ \PYGZsq{}}
               \PYG{k}{else}\PYG{p}{:}
                   \PYG{n}{equation} \PYG{o}{+=} \PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{coeff}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{x}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{idx}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{ \PYGZsq{}}
   \PYG{n}{equation} \PYG{o}{+=} \PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}= }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{coefficients}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}
   \PYG{k}{if} \PYG{n}{equation}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}+\PYGZsq{}}\PYG{p}{:}
       \PYG{n}{equation} \PYG{o}{=} \PYG{n}{equation}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:]}
   \PYG{k}{return} \PYG{n}{equation}

\PYG{c+c1}{\PYGZsh{} Функция для вывода системы линейных уравнений}
\PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{output\PYGZus{}sle}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{:} \PYG{n+nb}{list}\PYG{p}{):}
   \PYG{n}{output\PYGZus{}string} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}\PYGZob{}\PYGZsq{}}
   \PYG{k}{for} \PYG{n}{row} \PYG{o+ow}{in} \PYG{n}{matrix}\PYG{p}{:}
       \PYG{k}{if} \PYG{n}{is\PYGZus{}zero\PYGZus{}vector}\PYG{p}{(}\PYG{n}{row}\PYG{p}{):}
           \PYG{k}{continue}
       \PYG{n}{output\PYGZus{}string} \PYG{o}{+=} \PYG{n}{make\PYGZus{}linear\PYGZus{}equation}\PYG{p}{(}\PYG{n}{row}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{},}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}
   \PYG{n}{output\PYGZus{}string} \PYG{o}{=} \PYG{n}{output\PYGZus{}string}\PYG{p}{[:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}\PYGZcb{}\PYGZsq{}}
   \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{output\PYGZus{}string}\PYG{p}{)}
   \PYG{n+nb}{print}\PYG{p}{()}

\PYG{c+c1}{\PYGZsh{} Функция для получения всех базисных видов системы линейных уравнений}
\PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{get\PYGZus{}all\PYGZus{}basic\PYGZus{}views\PYGZus{}of\PYGZus{}SLE}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{:} \PYG{n+nb}{list}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n+nb}{list}\PYG{p}{:}
   \PYG{n}{sub\PYGZus{}matrix} \PYG{o}{=} \PYG{n}{clone\PYGZus{}matrix}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{)}
   \PYG{n}{set\PYGZus{}of\PYGZus{}basic\PYGZus{}vars} \PYG{o}{=} \PYG{n}{get\PYGZus{}all\PYGZus{}sets\PYGZus{}of\PYGZus{}basic\PYGZus{}vars}\PYG{p}{(}\PYG{n}{sub\PYGZus{}matrix}\PYG{p}{)}
   \PYG{n}{list\PYGZus{}of\PYGZus{}basic\PYGZus{}views} \PYG{o}{=} \PYG{p}{[]}

   \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{set\PYGZus{}of\PYGZus{}basic\PYGZus{}vars}\PYG{p}{:}
       \PYG{n}{result} \PYG{o}{=} \PYG{n}{Gauss\PYGZus{}Jordan\PYGZus{}eliminations}\PYG{p}{(}\PYG{n}{clone\PYGZus{}matrix}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{),} \PYG{n}{i}\PYG{p}{)}
       \PYG{k}{if} \PYG{n}{result} \PYG{o}{==} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{:}
           \PYG{k}{continue}
       \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{set\PYGZus{}of\PYGZus{}basic\PYGZus{}vars}\PYG{o}{.}\PYG{n}{index}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{. Базисные неизвестные:\PYGZsq{}}\PYG{p}{,} \PYG{n}{print\PYGZus{}vars}\PYG{p}{(}\PYG{n}{i}\PYG{p}{))}
       \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}Система:\PYGZsq{}}\PYG{p}{)}
       \PYG{n}{list\PYGZus{}of\PYGZus{}basic\PYGZus{}views}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{result}\PYG{p}{)}
       \PYG{n}{output\PYGZus{}sle}\PYG{p}{(}\PYG{n}{result}\PYG{p}{)}
   \PYG{k}{return} \PYG{n}{list\PYGZus{}of\PYGZus{}basic\PYGZus{}views}

\PYG{c+c1}{\PYGZsh{} Функция для преобразования дроби в float}
\PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{fract\PYGZus{}to\PYGZus{}float}\PYG{p}{(}\PYG{n}{x}\PYG{p}{:} \PYG{n}{Fraction}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n+nb}{float}\PYG{p}{:}
   \PYG{k}{return} \PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{x}\PYG{o}{.}\PYG{n}{numerator}\PYG{p}{)} \PYG{o}{/} \PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{x}\PYG{o}{.}\PYG{n}{denominator}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Функция для проверки, что все элементы вектора неотрицательные}
\PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{is\PYGZus{}all\PYGZus{}not\PYGZus{}negative}\PYG{p}{(}\PYG{n}{vector}\PYG{p}{:} \PYG{n+nb}{list}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n+nb}{bool}\PYG{p}{:}
   \PYG{k}{return} \PYG{n+nb}{all}\PYG{p}{(}\PYG{n}{fract\PYGZus{}to\PYGZus{}float}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)} \PYG{o}{\PYGZgt{}=} \PYG{l+m+mi}{0} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n}{vector}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Функция для нахождения опорных решений}
\PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{find\PYGZus{}reference\PYGZus{}solutions}\PYG{p}{(}\PYG{n}{list\PYGZus{}of\PYGZus{}basic\PYGZus{}views}\PYG{p}{:} \PYG{n+nb}{list}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n+nb}{list}\PYG{p}{:}
   \PYG{n}{list\PYGZus{}of\PYGZus{}reference\PYGZus{}solutions} \PYG{o}{=} \PYG{p}{[]}

   \PYG{k}{for} \PYG{n}{matrix} \PYG{o+ow}{in} \PYG{n}{list\PYGZus{}of\PYGZus{}basic\PYGZus{}views}\PYG{p}{:}
       \PYG{n}{solution\PYGZus{}vector} \PYG{o}{=} \PYG{n}{get\PYGZus{}column}\PYG{p}{(}\PYG{n}{clone\PYGZus{}matrix}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{),} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
       \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{is\PYGZus{}all\PYGZus{}not\PYGZus{}negative}\PYG{p}{(}\PYG{n}{solution\PYGZus{}vector}\PYG{p}{):}
           \PYG{k}{continue}

       \PYG{n}{solution\PYGZus{}matrix} \PYG{o}{=} \PYG{n}{clone\PYGZus{}matrix}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{)}
       \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{)):}
           \PYG{k}{for} \PYG{n}{y} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{[}\PYG{n}{x}\PYG{p}{])} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{):}
               \PYG{n}{col} \PYG{o}{=} \PYG{n}{get\PYGZus{}column}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{[:],} \PYG{n}{y}\PYG{p}{)}
               \PYG{k}{if} \PYG{o+ow}{not} \PYG{p}{(}\PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{col}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{1} \PYG{o+ow}{and} \PYG{n}{col}\PYG{o}{.}\PYG{n}{count}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{==} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{col}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{):}
                   \PYG{n}{solution\PYGZus{}matrix}\PYG{p}{[}\PYG{n}{x}\PYG{p}{][}\PYG{n}{y}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{0}

       \PYG{n}{list\PYGZus{}of\PYGZus{}reference\PYGZus{}solutions}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{solution\PYGZus{}matrix}\PYG{p}{)}
       \PYG{n}{output\PYGZus{}sle}\PYG{p}{(}\PYG{n}{solution\PYGZus{}matrix}\PYG{p}{)}

   \PYG{k}{return} \PYG{n}{list\PYGZus{}of\PYGZus{}reference\PYGZus{}solutions}

\PYG{c+c1}{\PYGZsh{} Функция для вычисления значения целевой функции}
\PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{goal}\PYG{p}{(}\PYG{n}{func}\PYG{p}{:} \PYG{n+nb}{list}\PYG{p}{,} \PYG{n}{basic\PYGZus{}matrix}\PYG{p}{:} \PYG{n+nb}{list}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n}{Fraction}\PYG{p}{:}
   \PYG{n}{result} \PYG{o}{=} \PYG{n}{Fraction}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} Инициализация дробным нулем}
   \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{basic\PYGZus{}matrix}\PYG{p}{)):}
       \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{func}\PYG{p}{)):}
           \PYG{k}{if} \PYG{n}{basic\PYGZus{}matrix}\PYG{p}{[}\PYG{n}{i}\PYG{p}{][}\PYG{n}{j}\PYG{p}{]} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{:}
               \PYG{n}{result} \PYG{o}{+=} \PYG{n}{func}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{*} \PYG{n}{basic\PYGZus{}matrix}\PYG{p}{[}\PYG{n}{i}\PYG{p}{][}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
   \PYG{k}{return} \PYG{n}{result}

\PYG{c+c1}{\PYGZsh{} Функция для нахождения оптимального плана}
\PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{find\PYGZus{}optimal\PYGZus{}plan}\PYG{p}{(}\PYG{n}{list\PYGZus{}of\PYGZus{}solutions}\PYG{p}{:} \PYG{n+nb}{list}\PYG{p}{,} \PYG{n}{func}\PYG{p}{:} \PYG{n+nb}{list}\PYG{p}{,} \PYG{n}{max\PYGZus{}or\PYGZus{}min}\PYG{p}{:} \PYG{n+nb}{str}\PYG{p}{)} \PYG{o}{\PYGZhy{}\PYGZgt{}} \PYG{n+nb}{tuple}\PYG{p}{:}
   \PYG{n}{min\PYGZus{}val} \PYG{o}{=} \PYG{n+nb}{float}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}inf\PYGZsq{}}\PYG{p}{)}
   \PYG{n}{max\PYGZus{}val} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{min\PYGZus{}val}
   \PYG{n}{res\PYGZus{}matrix\PYGZus{}min} \PYG{o}{=} \PYG{p}{[]}
   \PYG{n}{res\PYGZus{}matrix\PYGZus{}max} \PYG{o}{=} \PYG{p}{[]}

   \PYG{k}{for} \PYG{n}{matrix} \PYG{o+ow}{in} \PYG{n}{list\PYGZus{}of\PYGZus{}solutions}\PYG{p}{:}
       \PYG{n}{curr\PYGZus{}val} \PYG{o}{=} \PYG{n}{goal}\PYG{p}{(}\PYG{n}{func}\PYG{p}{,} \PYG{n}{matrix}\PYG{p}{)}
       \PYG{k}{if} \PYG{n}{curr\PYGZus{}val} \PYG{o}{\PYGZgt{}=} \PYG{n}{max\PYGZus{}val}\PYG{p}{:}
           \PYG{n}{res\PYGZus{}matrix\PYGZus{}max} \PYG{o}{=} \PYG{n}{matrix}
           \PYG{n}{max\PYGZus{}val} \PYG{o}{=} \PYG{n}{curr\PYGZus{}val}
       \PYG{k}{if} \PYG{n}{curr\PYGZus{}val} \PYG{o}{\PYGZlt{}=} \PYG{n}{min\PYGZus{}val}\PYG{p}{:}
           \PYG{n}{res\PYGZus{}matrix\PYGZus{}min} \PYG{o}{=} \PYG{n}{matrix}
           \PYG{n}{min\PYGZus{}val} \PYG{o}{=} \PYG{n}{curr\PYGZus{}val}

   \PYG{k}{if} \PYG{n}{max\PYGZus{}or\PYGZus{}min} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}min\PYGZsq{}}\PYG{p}{:}
       \PYG{k}{return} \PYG{p}{(}\PYG{n}{min\PYGZus{}val}\PYG{p}{,} \PYG{n}{res\PYGZus{}matrix\PYGZus{}min}\PYG{p}{)}
   \PYG{k}{return} \PYG{p}{(}\PYG{n}{max\PYGZus{}val}\PYG{p}{,} \PYG{n}{res\PYGZus{}matrix\PYGZus{}max}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Основная часть программы}
\PYG{n}{equation\PYGZus{}num} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}Количество уравнений в системе: \PYGZdq{}}\PYG{p}{))}
\PYG{n}{a} \PYG{o}{=} \PYG{p}{[[]} \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{equation\PYGZus{}num}\PYG{p}{)]}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{equation\PYGZus{}num}\PYG{p}{):}
   \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}Коэффициенты уравнения }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{end}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
   \PYG{n}{a}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{extend}\PYG{p}{(}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{map}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{,} \PYG{n+nb}{input}\PYG{p}{()}\PYG{o}{.}\PYG{n}{split}\PYG{p}{())))}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}Целевая функция (}\PYG{l+s+si}{\PYGZob{}}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{])}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{ чисел)\PYGZsq{}}\PYG{p}{)}
\PYG{n}{func} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{map}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{,} \PYG{n+nb}{input}\PYG{p}{()}\PYG{o}{.}\PYG{n}{split}\PYG{p}{()))}
\PYG{n}{max\PYGZus{}or\PYGZus{}min} \PYG{o}{=} \PYG{n+nb}{input}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}Введите \PYGZdq{}max\PYGZdq{}, если значение функции стремится к максимуму, иначе \PYGZdq{}min\PYGZdq{}:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}Введенная система уравнений:\PYGZsq{}}\PYG{p}{)}
\PYG{n}{output\PYGZus{}sle}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}Все базисные виды системы:\PYGZsq{}}\PYG{p}{)}
\PYG{n}{all\PYGZus{}basic\PYGZus{}views} \PYG{o}{=} \PYG{n}{get\PYGZus{}all\PYGZus{}basic\PYGZus{}views\PYGZus{}of\PYGZus{}SLE}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}Опорные решения системы:\PYGZsq{}}\PYG{p}{)}
\PYG{n}{reference\PYGZus{}solutions} \PYG{o}{=} \PYG{n}{find\PYGZus{}reference\PYGZus{}solutions}\PYG{p}{(}\PYG{n}{all\PYGZus{}basic\PYGZus{}views}\PYG{p}{)}

\PYG{n}{optimal\PYGZus{}solution} \PYG{o}{=} \PYG{n}{find\PYGZus{}optimal\PYGZus{}plan}\PYG{p}{(}\PYG{n}{reference\PYGZus{}solutions}\PYG{p}{,} \PYG{n}{func}\PYG{p}{,} \PYG{n}{max\PYGZus{}or\PYGZus{}min}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}Оптимальное решение для z = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{func}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{:\PYGZsq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{fract\PYGZus{}to\PYGZus{}float}\PYG{p}{(}\PYG{n}{optimal\PYGZus{}solution}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]),} \PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}(}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{optimal\PYGZus{}solution}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{)\PYGZsq{}}\PYG{p}{)}
\PYG{n}{output\PYGZus{}sle}\PYG{p}{(}\PYG{n}{optimal\PYGZus{}solution}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{])}
\end{Verbatim}
