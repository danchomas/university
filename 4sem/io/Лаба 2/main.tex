\documentclass{report}

\usepackage[russian]{babel}
\usepackage{geometry}
\usepackage{minted2}
\usepackage[hidelinks]{hyperref}
\usepackage{xcolor}
\usepackage{xspace}
\usepackage{fancyhdr}
\usepackage{tocloft}
\usepackage{booktabs}
\usepackage{tikz}
\usepackage{titlesec}
\usepackage{tabularx}
\usepackage{setspace}
\usepackage{makecell}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{amsmath}
\usepackage{array}
\usepackage{cancel}
\usepackage{multirow}

\usetikzlibrary{shapes, arrows}
\usetikzlibrary{positioning}
\usetikzlibrary{shapes.geometric}
\usetikzlibrary{shapes.misc}
\usetikzlibrary{calc}
\usetikzlibrary{chains}
\usetikzlibrary{babel}

\tikzstyle{pf} = [circle, draw, text centered, minimum height = 2em]
\tikzstyle{rec} = [rectangle, draw, text centered, rounded corners, minimum height=2em]
\tikzstyle{proc} = [rectangle, draw, text centered, minimum height=2em]
\tikzstyle{dec} = [diamond, draw, text centered, minimum height=2em]
\tikzstyle{io}=[trapezium, draw, text centered, trapezium left angle=60, trapezium right angle=120, minimum height=2em]
\tikzstyle{cyc}=[chamfered rectangle, draw, text centered,chamfered rectangle xsep=10pt]
\tikzstyle{con} = [draw, -latex']

\tikzset{
	up left connect/.style={
		to path={(\tikztostart.south) -- ++ (0, -0.15) -- ++ (-#1, 0) |- (\tikztotarget)}
	},
	down right connect/.style={
		to path={(\tikztostart) -- ++ (#1, 0) |- ($(\tikztotarget.north) + (0, 0.2)$) -- (\tikztotarget)}
	}
}

\newcommand{\drawzalupa}[2]{
	\begin{figure}[H]
		%\begin{center}
		\centering
		\includegraphics[width=#2\textwidth]{#1}
		%\end{center}
	\end{figure}
}

\setlength{\cftaftertoctitleskip}{2pt}

\renewcommand{\cfttoctitlefont}{\LARGE\bfseries}

\titleformat{\chapter}{\normalfont\LARGE\bfseries}{\thechapter}{20pt}{\LARGE\bfseries}
\titlespacing*{\chapter}{0pt}{0pt}{20pt}

\pagestyle{fancy}

\fancyhf{}

\fancyfoot[C]{\thepage}

\renewcommand{\headrulewidth}{0pt}

\renewcommand{\footrulewidth}{0pt}


\definecolor{pybg}{rgb}{0.95,0.95,0.95}


\geometry{left=3cm}
\geometry{right=1.5cm}
\geometry{top=2cm}
\geometry{bottom=2cm}

\counterwithout{figure}{chapter}

\newcommand{\q}[1]{``#1''}

\newminted[code]{cpp}{
	bgcolor=pybg,
	baselinestretch=1.2,
	fontsize=\normalsize,
	tabsize=0,
	linenos,
	obeytabs=true,
	tabsize=4
}

\begin{document}
	\begin{titlepage}
		\begin{center}
			МИНИСТЕРСТВО НАУКИ И ВЫСШЕГО ОБРАЗОВАНИЯ\linebreak 
			РОССИЙСКОЙ ФЕДЕРАЦИИ\medskip
			
			ФЕДЕРАЛЬНОЕ ГОСУДАРСТВЕННОЕ БЮДЖЕТНОЕ ОБРАЗОВАТЕЛЬНОЕ 
			УЧРЕЖДЕНИЕ ВЫСШЕГО ОБРАЗОВАНИЯ\medskip
			
			\textbf{
				«БЕЛГОРОДСКИЙ ГОСУДАРСТВЕННЫЙ \linebreak
				ТЕХНОЛОГИЧЕСКИЙ УНИВЕРСИТЕТ им. В. Г. ШУХОВА»\linebreak
				(БГТУ им. В.Г. Шухова)
			}\bigskip
			
			Кафедра программного обеспечения вычислительной техники и автоматизированных систем
			\vspace{5cm}
			
			\Large\textbf{Лабораторная работа №2}
			
			\large по дисциплине: Исследование операций\linebreak
			тема: \q{Симплекс-метод в чистом виде}
		\end{center}\vspace{6cm}
		
		\begin{flushright}
			\begin{minipage}{7cm}
				Выполнил: ст. группы ВТ-231\\
				Масленников Даниил\\
				\\
				Проверил: \\
				Вирченко Юрий Петрович\\
			\end{minipage}
		\end{flushright}\bigskip
		
		\
		
		\
		
		\
		
		\
		
		
		\begin{center}
			Белгород, 2025 г.
		\end{center}
	\end{titlepage}
	
	\newpage
	
	\setcounter{secnumdepth}{-1}
	\chapter{Лабораторная работа №2 <<Симплекс-метод в чистом виде.>>}
	
	\textbf{Цель работы:} изучение симплекс-метода для решения задачи
	линейного программирования с использованием симплекс-таблиц,
	получение навыков кодирования изученного алгоритма, отладки и
	тестирования соответствующих программ.
	\begin{center}
		\textbf{Вариант 14}
	\end{center}
		\begin{center}
		\textbf{Задания для подготовки к работе}
	\end{center}

	\begin{enumerate}
		\item{Выяснить: какой вид должна иметь задача ЛП, чтобы можно было
			применять симплекс-метод в чистом виде, а также как составляется
			первая симплекс-таблица?} 
		\item{Изучить алгоритм перехода от одной симплекс-таблицы к другой
			при решении задачи симплекс-методом.} 
		\item{Запрограммировать и отладить изученный алгоритм. В рамках
			подготовки тестовых данных аналитически решить задачу:}
	\end{enumerate}
	
	\begin{center}\Large
	$z = 6x_2 + 9x_4 + 2x_6 \rightarrow max;$
	\end{center}
	
	\[
	\Large\left\{
	\begin{aligned}
		&5x_2 + 5x_4 + x_5 + x_6 = 26, \\
		&x_1 - 3x_2 - 4x_4 - 2x_6 = 10, \\
		&4x_2 + x_3 - 6x_4 - 3x_6 = 12,
	\end{aligned}
	\right.
	\]
	
	\begin{center}\Large
	$x_i \geq 0 (i = \overline{1,6})$
	\end{center}
	
	
	\newpage
	
	\chapter{Задание 1}
	Выяснить: какой вид должна иметь задача ЛП, чтобы можно было
	применять симплекс-метод в чистом виде, а также как составляется
	первая симплекс-таблица?
	
	\textbf{Ответ:} Для непосредственного применения симплекс-метода задача линейного программирования должна быть представлена в \textit{канонической форме} (или, иначе говоря, в базисном виде с допустимым начальным решением). В наиболее простом случае это подразумевает следующее:
	
	Необходимо найти максимум целевой функции:
	
	\[ z = c_1x_1 + c_2x_2 + \dots + c_nx_n \rightarrow \max, \]
	
	которая задана при системе линейных ограничений в виде уравнений:
	
	\[
	\begin{cases}
		a_{11}x_1 + a_{12}x_2 + \dots + a_{1n}x_n = b_1, \\
		a_{21}x_1 + a_{22}x_2 + \dots + a_{2n}x_n = b_2, \\
		\vdots \\
		a_{m1}x_1 + a_{m2}x_2 + \dots + a_{mn}x_n = b_m,
	\end{cases}
	\]
	
	и условиях неотрицательности переменных: \( x_i \geq 0 \) для всех \( i = 1, 2, \dots, n \).
	
	
	Для \textit{запуска} симплекс-метода требуется: 
	\begin{enumerate} 
	\itemПривести систему к \textit{базисному виду}, то есть выбрать \( m \) базисных переменных и выразить их через оставшиеся \( n - m \) переменных. При этом начальное базисное решение должно быть \textit{допустимым}, что означает неотрицательность всех базисных переменных на первом шаге.
	\itemПреобразовать целевую функцию, исключив из неё базисные переменные. Это означает, что \( z \) должна быть выражена только через свободные (небазисные) переменные.  
	
	Если допустимое начальное (опорное) решение существует, то можно построить первую симплекс-таблицу и выполнять итеративные преобразования, двигаясь к оптимальному решению. В процессе также может быть выявлена неограниченность целевой функции или несовместность системы ограничений.
	\end{enumerate}
	
	\chapter{Задание 2}
	
	Построение начальной симплекс-таблицы
	
	Предположим, что после приведения системы к базисному виду мы получили следующие выражения для базисных переменных:
	
	\[
	\begin{aligned}
		x_{1} &= b_{1} - a_{1,r+1}x_{r+1} - \cdots - a_{1,n}x_{n}, \\
		x_{2} &= b_{2} - a_{2,r+1}x_{r+1} - \cdots - a_{2,n}x_{n}, \\
		&\vdots \\
		x_{r} &= b_{r} - a_{r,r+1}x_{r+1} - \cdots - a_{r,n}x_{n},
	\end{aligned}
	\]
	
	где:
	- \(x_{1}, x_{2}, \ldots, x_{r}\) — базисные переменные,
	- \(x_{r+1}, \ldots, x_{n}\) — свободные переменные,
	- \(b_{1}, \ldots, b_{r} \geq 0\) (условие допустимости решения).
	
	Целевая функция выражена исключительно через свободные переменные:
	
	\[
	z = \gamma_{0} + \gamma_{r+1}x_{r+1} + \cdots + \gamma_{n}x_{n} \to \max.
	\]
	
	Для построения симплекс-таблицы выполним следующие преобразования:
	1. Перенесём все слагаемые с переменными в левую часть уравнений, оставив свободные члены справа.
	2. Целевую функцию представим в виде:
	
	\[
	z - \gamma_{r+1}x_{r+1} - \cdots - \gamma_{n}x_{n} = \gamma_{0}.
	\]
	
	Полученная система уравнений и целевая функция представляются в виде следующей симплекс-таблицы:
	
	\[
	\begin{array}{c|ccccc}
		& \text{Св. член} & x_{1} & x_{2} & \cdots & x_{n} \\
		\hline
		x_{1} & b_{1} & 1 & 0 & \cdots & a_{1,n} \\
		x_{2} & b_{2} & 0 & 1 & \cdots & a_{2,n} \\
		\vdots & \vdots & \vdots & \vdots & \ddots & \vdots \\
		x_{r} & b_{r} & 0 & 0 & \cdots & a_{r,n} \\
		\hline
		z & \gamma_{0} & 0 & 0 & \cdots & -\gamma_{n} \\
	\end{array}
	\]
	
	\textbf{Пояснения к таблице:}
	\begin{itemize}
		\item В первом столбце указаны базисные переменные.
		\item Столбец "Св. член" содержит значения \(b_{i}\) для уравнений и \(\gamma_{0}\) для целевой функции.
		\item В строке \(z\) коэффициенты при переменных записаны со знаком "минус", что соответствует преобразованной форме целевой функции.
	\end{itemize}
	
	Эта таблица представляет собой \textbf{начальный этап} симплекс-метода. На последующих шагах:
	\begin{itemize}
		\item Выбирается разрешающий элемент.
		\item Таблица преобразуется для перехода к новому базисному решению.
		\item Значение целевой функции при этом не уменьшается.
	\end{itemize}
	
	Процесс продолжается до выполнения критерия оптимальности, который заключается в отсутствии положительных коэффициентов в строке \(z\) при свободных переменных.
	
	\newpage
	\LARGE\textbf{Задание 3}
	
	
	
	
	
	\normalsize{Блок-схемы:}
	
	\begin{center}
		\begin{tikzpicture}[node distance = 1.2cm]
			\node (terminator)[rec]{solveSimplexMethod(A, b, z)};
			\node (1)[proc, below of = terminator, text width = 6cm, yshift = -0.2cm]{Число ограничений m := A.size(); Число переменных n := A[0].size()};
			\node (2)[proc, below of = 1, text width = 6cm, yshift = -1cm]{Формируем симплекс-таблицу: первые m строк - ограничения, последняя строка - строка целевой функции};
			
			\node (cyc1)[dec, below of = 2, yshift = -3.5cm]{isNegativeInLastRow(table) = true};
			\node (3)[proc, below of = cyc1, yshift = -3cm]{Находим опорную строку и столбец};
			\node (dec1)[dec, below of = 3, yshift = -1cm]{pivotRow = -1};
			\node (dec1true)[rec, below of = dec1, xshift = 3cm]{Решений нет};
			\node (4)[proc, below of = dec1, yshift = -1.5cm]{performPivot(table, pivotRow, pivotCol)};
			\node (5)[proc, below of = 4]{Вывести симплекс-таблицу};
			\node (6)[proc, below of = 5, text width = 6cm, yshift = -0.5cm]{Если отрицательных элементов не осталось, решение оптимально};
			\node (7)[rec, below of = 6, yshift = -0.2cm]{Вернуть решение};
			
			
			\draw [con] (terminator) -- (1);
			\draw [con] (1) -- (2);
			\draw [con] (2) -- (cyc1);
			\path (cyc1) edge [con, down right connect = 6] (6);
			\path (5) edge [con, up left connect = 6] (cyc1);
			\draw [con] (cyc1) -- (3);
			\draw [con] (3) -- (dec1);
			\draw [con] (dec1) -| (dec1true);
			\draw [con] (dec1.west) -- ++(-1.5, 0) -- ++(0, -2) -| (4);
			\draw [con] (4) -- (5);
			\draw [con] (6) -- (7);
		\end{tikzpicture}
	\end{center}
	
	\newpage
	
	\begin{center}
		\begin{tikzpicture}[node distance = 1.2cm]
			\node (terminator)[rec]{performPivot(table, pivotRow, pivotCol)};
			\node (1)[proc, below of = terminator]{Делим строку на опорный элемент};
			\node (cyc1) [cyc, below of = 1]{i \dots numRows};
			\node (dec1) [dec, below of = cyc1, yshift = -1cm]{i != pivotRow};
			\node (dec1true) [proc, below of = dec1, xshift = 3.5cm]{factor := table[i][pivotCol]};
			\node (cyc2)[cyc, below of = dec1true] {j \dots numCols};
			\node (2)[proc, below of = cyc2]{table[i][j] -= factor * table[pivotRow][j]};
			\node (end)[rec, below of = dec1, yshift = -4.3cm]{performPivot(table, pivotRow, pivotCol)};
			
			\coordinate [below of=dec1, yshift=-3.1cm] (p1) {};
			
			\draw [con] (terminator) -- (1);
			\draw [con] (1) -- (cyc1);
			\path (cyc1) edge [con, down right connect = 8] (end);
			\path (2) edge [con, up left connect = 3.5] (cyc2);
			\draw (cyc2.east) -- ++(2, 0) |- (p1) -- ++(-3.4, 0) |- (dec1.west);
			\draw [con] (cyc1) -- (dec1);
			\draw [con] (dec1) -| (dec1true);
			\draw [con] (dec1true) -- (cyc2);
			\draw [con] (p1) -- ++(0, -0.3) -- ++(-7, 0) |- (cyc1.west);
			\draw [con] (cyc2) -- (2);
		\end{tikzpicture}
	\end{center}
	
	\newpage
	
	\section{Код программы:}
	\begin{code}
#include <iostream>
#include <vector>
#include <limits>
#include <iomanip>
#include <algorithm>
#include <tuple>  

using namespace std;

typedef vector<vector<double>> Matrix;
typedef vector<double> Vector;

pair<int, int> find_pivot(const Matrix& table) {
	// Находим столбец с минимальным элементом в последней строке (кроме последнего элемента)
	int col = 0;
	double min_val = table.back()[0];
	for (size_t i = 1; i < table.back().size() - 1; ++i) {
		if (table.back()[i] < min_val) {
			min_val = table.back()[i];
			col = i;
		}
	}
	
	// Если все элементы неотрицательные, решение найдено
	if (min_val >= 0) {
		return make_pair(-1, -1);
	}
	
	// Ищем строку с минимальным положительным отношением
	int row = -1;
	double min_ratio = numeric_limits<double>::max();
	for (size_t i = 0; i < table.size() - 1; ++i) {
		if (table[i][col] > 0) {
			double ratio = table[i].back() / table[i][col];
			if (ratio < min_ratio) {
				min_ratio = ratio;
				row = i;
			}
		}
	}
	
	return make_pair(row, col);
}

void perform_pivot(Matrix& table, int pivot_row, int pivot_col) {
	// Нормализуем разрешающую строку
	double pivot_val = table[pivot_row][pivot_col];
	for (double& val : table[pivot_row]) {
		val /= pivot_val;
	}
	
	// Обновляем остальные строки
	for (size_t i = 0; i < table.size(); ++i) {
		if (i != static_cast<size_t>(pivot_row)) {
			double factor = table[i][pivot_col];
			for (size_t j = 0; j < table[i].size(); ++j) {
				table[i][j] -= factor * table[pivot_row][j];
			}
		}
	}
}

void print_simplex_table(const Matrix& table, int row, int col) {
	if (row == -1) {
		cout << "Исходная симплекс-таблица:\n";
	}
	else {
		cout << "Шаг - pivot = (" << row + 1 << ", " << col + 1 << "):\n";
	}
	
	cout << "     ";  
	for (size_t i = 0; i < table[0].size() - 1; ++i) {
		cout << "x" << i + 1 << "        ";
	}
	cout << "b       \n";
	
	for (const auto& r : table) {
		for (double val : r) {
			cout << fixed << setprecision(2) << setw(8) << val << "  ";
		}
		cout << "\n";
	}
	cout << endl;
}

pair<double, Vector> solve_system(const Matrix& table, size_t vars) {
	double maximum = table.back().back();
	Vector result(vars, 0.0);
	
	for (size_t i = 0; i < table.size() - 1; ++i) {
		for (size_t j = 0; j < vars; ++j) {
			if (table[i][j] == 1.0) {
				bool is_basic = true;
				for (size_t k = 0; k < table.size() - 1; ++k) {
					if (k != i && table[k][j] != 0.0) {
						is_basic = false;
						break;
					}
				}
				if (is_basic) {
					result[j] = table[i].back();
					break;
				}
			}
		}
	}
	
	return make_pair(maximum, result);
}

bool is_negative_in_last_row(const Matrix& table) {
	for (size_t i = 0; i < table.back().size() - 1; ++i) {
		if (table.back()[i] < 0) {
			return true;
		}
	}
	return false;
}

tuple<bool, double, Vector> solve_simplex_method(Matrix A, Vector b, Vector z) {
	// Добавляем 0 к целевой функции
	z.push_back(0.0);
	
	// Формируем симплекс-таблицу
	Matrix table = A;
	for (size_t i = 0; i < table.size(); ++i) {
		table[i].push_back(b[i]);
	}
	Vector last_row;
	for (double val : z) {
		last_row.push_back(-val);
	}
	last_row.back() = z.back();
	table.push_back(last_row);
	
	print_simplex_table(table, -1, -1);
	
	while (is_negative_in_last_row(table)) {
		auto pivot = find_pivot(table);
		int pivot_row = pivot.first;
		int pivot_col = pivot.second;
		if (pivot_row == -1) {
			return make_tuple(false, 0.0, Vector());
		}
		
		perform_pivot(table, pivot_row, pivot_col);
		print_simplex_table(table, pivot_row, pivot_col);
	}
	
	auto solution = solve_system(table, A[0].size());
	double maximum = solution.first;
	Vector result = solution.second;
	return make_tuple(true, maximum, result);
}

int main() {
	setlocale(LC_ALL, "Russian");

	Matrix A = {
		{0, 5, 0, 5, 1, 1},  // Первое уравнение
		{1, -3, 0, -4, 0, -2}, // Второе уравнение
		{0, 4, 1, -6, 0, -3}   // Третье уравнение
	};
	
	// Вектор правых частей
	Vector b = { 26, 10, 12 };
	
	// Коэффициенты целевой функции 
	Vector z = { 0, 6, 0, 9, 0, 2 };
	
	auto result = solve_simplex_method(A, b, z);
	bool success = get<0>(result);
	double maximum = get<1>(result);
	Vector solution = get<2>(result);
	
	if (success) {
		cout << "\nМаксимум целевой функции: " << maximum << "\n";
		cout << "Оптимальный план: ";
		for (size_t i = 0; i < solution.size(); ++i) {
			cout << "x" << i + 1 << " = " << solution[i];
			if (i != solution.size() - 1) cout << ", ";
		}
		cout << endl;
	}
	else {
		cout << "Решение не найдено" << endl;
	}
	
	return 0;
}
	\end{code}
	
	Результат работы программы:
	
	\drawzalupa{images/task1.png}{1}
	
	\newpage
	
	\section{Аналитическое решение}
	
	\begin{enumerate}
		\item \textbf{Постановка задачи}
		
		Дана задача линейного программирования:
	\begin{center}
		$z = 6x_2 + 9x_4 + 2x_6 \rightarrow max;$
	\end{center}
	
	\[
	\left\{
	\begin{aligned}
		&5x_2 + 5x_4 + x_5 + x_6 = 26, \\
		&x_1 - 3x_2 - 4x_4 - 2x_6 = 10, \\
		&4x_2 + x_3 - 6x_4 - 3x_6 = 12,
	\end{aligned}
	\right.
	\]
	
	\begin{center}
		$x_i \geq 0 (i = \overline{1,6})$
	\end{center}
		
		\item \textbf{Решение}
		\begin{itemize}
			\item Начальное базисное решение:
			\[
			x_1 = 10,\quad x_3 = 12,\quad x_5 = 26,\quad x_2 = x_4 = x_6 = 0
			\]
			Начальное значение целевой функции: \( z = 0 \).
			
			\item Симплекс-таблица (начальная):
			\begin{center}
				\begin{tabular}{ccccccccc}
					\toprule
					Баз.пер. & $b$ & $x_1$ & $x_2$ & $x_3$ & $x_4$ & $x_5$ & $x_6$ \\
					\midrule
					$x_1$    & 10  & 1     & -3    & 0     & -4    & 0     & -2    \\
					$x_3$    & 12  & 0     & 4     & 1     & -6    & 0     & -3    \\
					$x_5$    & 26  & 0     & 5     & 0     & 5     & 1     & 1     \\
					$-Z$     & 0   & 0     & -6    & 0     & -9    & 0     & -2    \\
					\bottomrule
				\end{tabular}
			\end{center}
			
			\item Итерация 1:
			\begin{itemize}
				\item Разрешающий столбец: $x_4$ (наибольший по модулю отрицательный коэффициент)
				\item Отношения $b/a_{i4}$:
				\[
				x_1: 10/(-4) < 0 \quad (\text{пропускаем}), \quad
				x_3: 12/(-6) < 0 \quad (\text{пропускаем}), \quad
				x_5: 26/5 = 5.2
				\]
				\item Разрешающая строка: $x_5$, элемент: 5
			\end{itemize}
			
			После преобразований:
			\begin{center}
				\begin{tabular}{ccccccccc}
					\toprule
					Баз.пер. & $b$ & $x_1$ & $x_2$ & $x_3$ & $x_4$ & $x_5$ & $x_6$ \\
					\midrule
					$x_1$    & 30.8 & 1     & 1     & 0     & 0     & 0.8   & -1.2  \\
					$x_3$    & 43.2 & 0     & 10    & 1     & 0     & 1.2   & -1.8  \\
					$x_4$    & 5.2  & 0     & 1     & 0     & 1     & 0.2   & 0.2   \\
					$-Z$     & 46.8 & 0     & 3     & 0     & 0     & 1.8   & -0.2  \\
					\bottomrule
				\end{tabular}
			\end{center}
			
			\item Итерация 2:
			\begin{itemize}
				\item Разрешающий столбец: $x_6$ (единственный отрицательный коэффициент)
				\item Отношения:
				\[
				x_1: 30.8/(-1.2) < 0 \quad (\text{пропускаем}), \quad
				x_3: 43.2/(-1.8) < 0 \quad (\text{пропускаем}), \quad
				x_4: 5.2/0.2 = 26
				\]
				\item Разрешающая строка: $x_4$, элемент: 0.2
			\end{itemize}
			
			Результат:
			\begin{center}
				\begin{tabular}{ccccccccc}
					\toprule
					Баз.пер. & $b$ & $x_1$ & $x_2$ & $x_3$ & $x_4$ & $x_5$ & $x_6$ \\
					\midrule
					$x_1$    & 62   & 1     & 7     & 0     & 6     & 2     & 0     \\
					$x_3$    & 90   & 0     & 19    & 1     & 9     & 3     & 0     \\
					$x_6$    & 26   & 0     & 5     & 0     & 5     & 1     & 1     \\
					$-Z$     & 52   & 0     & 4     & 0     & 1     & 2     & 0     \\
					\bottomrule
				\end{tabular}
			\end{center}
			
			\item Оптимальное решение:
			\[
			x_1 = 62,\quad x_3 = 90,\quad x_6 = 26,\quad x_2 = x_4 = x_5 = 0
			\]
		    \item Максимальное значение:
			\[
			z_{\max} = 52
			\]
		\end{itemize}
	\end{enumerate}
	
	\textbf{Вывод: }аналитическое решение совпадает с результатом написанной мной программы, что подтверждает корректность симплекс-метода.
\end{document}

