#include <iostream>
#include <vector>
#include <limits>
#include <iomanip>
#include <algorithm>
#include <tuple>

using namespace std;

typedef vector<vector<double>> Matrix;
typedef vector<double> Vector;

pair<int, int> find_pivot(const Matrix& table) {
	// Находим столбец с минимальным элементом в последней строке (кроме последнего элемента)
	int col = 0;
	double min_val = table.back()[0];
	for (size_t i = 1; i < table.back().size() - 1; ++i) {
		if (table.back()[i] < min_val) {
			min_val = table.back()[i];
			col = i;
		}
	}
	
	// Если все элементы неотрицательные, решение найдено
	if (min_val >= 0) {
		return make_pair(-1, -1);
	}
	
	// Ищем строку с минимальным положительным отношением
	int row = -1;
	double min_ratio = numeric_limits<double>::max();
	for (size_t i = 0; i < table.size() - 1; ++i) {
		if (table[i][col] > 0) {
			double ratio = table[i].back() / table[i][col];
			if (ratio < min_ratio) {
				min_ratio = ratio;
				row = i;
			}
		}
	}
	
	return make_pair(row, col);
}

void perform_pivot(Matrix& table, int pivot_row, int pivot_col) {
	// Нормализуем разрешающую строку
	double pivot_val = table[pivot_row][pivot_col];
	for (double& val : table[pivot_row]) {
		val /= pivot_val;
	}
	
	// Обновляем остальные строки
	for (size_t i = 0; i < table.size(); ++i) {
		if (i != static_cast<size_t>(pivot_row)) {
			double factor = table[i][pivot_col];
			for (size_t j = 0; j < table[i].size(); ++j) {
				table[i][j] -= factor * table[pivot_row][j];
			}
		}
	}
}

void print_simplex_table(const Matrix& table, int row, int col) {
	if (row == -1) {
		cout << "Исходная симплекс-таблица:\n";
	}
	else {
		cout << "Шаг - pivot = (" << row + 1 << ", " << col + 1 << "):\n";
	}
	
	cout << "     ";
	for (size_t i = 0; i < table[0].size() - 1; ++i) {
		cout << "x" << i + 1 << "        ";
	}
	cout << "b       \n";
	
	for (const auto& r : table) {
		for (double val : r) {
			cout << fixed << setprecision(2) << setw(8) << val << "  ";
		}
		cout << "\n";
	}
	cout << endl;
}

pair<double, Vector> solve_system(const Matrix& table, size_t vars) {
	double maximum = table.back().back();
	Vector result(vars, 0.0);
	
	for (size_t i = 0; i < table.size() - 1; ++i) {
		for (size_t j = 0; j < vars; ++j) {
			if (table[i][j] == 1.0) {
				bool is_basic = true;
				for (size_t k = 0; k < table.size() - 1; ++k) {
					if (k != i && table[k][j] != 0.0) {
						is_basic = false;
						break;
					}
				}
				if (is_basic) {
					result[j] = table[i].back();
					break;
				}
			}
		}
	}
	
	return make_pair(maximum, result);
}

bool is_negative_in_last_row(const Matrix& table) {
	for (size_t i = 0; i < table.back().size() - 1; ++i) {
		if (table.back()[i] < 0) {
			return true;
		}
	}
	return false;
}

tuple<bool, double, Vector> solve_simplex_method(Matrix A, Vector b, Vector z) {
	// Добавляем 0 к целевой функции
	z.push_back(0.0);
	
	// Формируем симплекс-таблицу
	Matrix table = A;
	for (size_t i = 0; i < table.size(); ++i) {
		table[i].push_back(b[i]);
	}
	Vector last_row;
	for (double val : z) {
		last_row.push_back(-val);
	}
	last_row.back() = z.back();
	table.push_back(last_row);
	
	print_simplex_table(table, -1, -1);
	
	while (is_negative_in_last_row(table)) {
		auto pivot = find_pivot(table);
		int pivot_row = pivot.first;
		int pivot_col = pivot.second;
		if (pivot_row == -1) {
			return make_tuple(false, 0.0, Vector());
		}
		
		perform_pivot(table, pivot_row, pivot_col);
		print_simplex_table(table, pivot_row, pivot_col);
	}
	
	auto solution = solve_system(table, A[0].size());
	double maximum = solution.first;
	Vector result = solution.second;
	return make_tuple(true, maximum, result);
}

int main() {
	setlocale(LC_ALL, "Russian");

	Matrix A = {
		{0, 5, 0, 5, 1, 1},  // Первое уравнение
		{1, -3, 0, -4, 0, -2}, // Второе уравнение
		{0, 4, 1, -6, 0, -3}   // Третье уравнение
	};
	
	// Вектор правых частей
	Vector b = { 26, 10, 12 };
	
	// Коэффициенты целевой функции
	Vector z = { 0, 6, 0, 9, 0, 2 };
	
	auto result = solve_simplex_method(A, b, z);
	bool success = get<0>(result);
	double maximum = get<1>(result);
	Vector solution = get<2>(result);
	
	if (success) {
		cout << "\nМаксимум целевой функции: " << maximum << "\n";
		cout << "Оптимальный план: ";
		for (size_t i = 0; i < solution.size(); ++i) {
			cout << "x" << i + 1 << " = " << solution[i];
			if (i != solution.size() - 1) cout << ", ";
		}
		cout << endl;
	}
	else {
		cout << "Решение не найдено" << endl;
	}
	
	return 0;
}
