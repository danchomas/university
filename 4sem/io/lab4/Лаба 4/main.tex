\documentclass{report}


\usepackage[russian]{babel}
\usepackage{geometry}
\usepackage{minted2}
\usepackage[hidelinks]{hyperref}
\usepackage{xcolor}
\usepackage{xspace}
\usepackage{fancyhdr}
\usepackage{tocloft}
\usepackage{booktabs}
\usepackage{tikz}
\usepackage{titlesec}
\usepackage{tabularx}
\usepackage{setspace}
\usepackage{makecell}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{amsmath}
\usepackage{array}
\usepackage{cancel}
\usepackage{multirow}
\usepackage{amsmath}
\usepackage{amssymb}

\usetikzlibrary{shapes, arrows}
\usetikzlibrary{positioning}
\usetikzlibrary{shapes.geometric}
\usetikzlibrary{shapes.misc}
\usetikzlibrary{calc}
\usetikzlibrary{chains}
\usetikzlibrary{babel}

\tikzstyle{pf} = [circle, draw, text centered, minimum height = 2em]
\tikzstyle{rec} = [rectangle, draw, text centered, rounded corners, minimum height=2em]
\tikzstyle{proc} = [rectangle, draw, text centered, minimum height=2em]
\tikzstyle{dec} = [diamond, draw, text centered, minimum height=2em]
\tikzstyle{io}=[trapezium, draw, text centered, trapezium left angle=60, trapezium right angle=120, minimum height=2em]
\tikzstyle{cyc}=[chamfered rectangle, draw, text centered,chamfered rectangle xsep=10pt]
\tikzstyle{con} = [draw, -latex']

\tikzset{
	up left connect/.style={
		to path={(\tikztostart.south) -- ++ (0, -0.15) -- ++ (-#1, 0) |- (\tikztotarget)}
	},
	down right connect/.style={
		to path={(\tikztostart) -- ++ (#1, 0) |- ($(\tikztotarget.north) + (0, 0.2)$) -- (\tikztotarget)}
	}
}

\newcommand{\drawzalupa}[2]{
	\begin{figure}[H]
		%\begin{center}
		\centering
		\includegraphics[width=#2\textwidth]{#1}
		%\end{center}
	\end{figure}
}

\setlength{\cftaftertoctitleskip}{2pt}

\renewcommand{\cfttoctitlefont}{\LARGE\bfseries}

\titleformat{\chapter}{\normalfont\LARGE\bfseries}{\thechapter}{20pt}{\LARGE\bfseries}
\titlespacing*{\chapter}{0pt}{0pt}{20pt}

\pagestyle{fancy}

\fancyhf{}

\fancyfoot[C]{\thepage}

\renewcommand{\headrulewidth}{0pt}

\renewcommand{\footrulewidth}{0pt}


\definecolor{pybg}{rgb}{0.95,0.95,0.95}


\geometry{left=3cm}
\geometry{right=1.5cm}
\geometry{top=2cm}
\geometry{bottom=2cm}

\counterwithout{figure}{chapter}

\newcommand{\q}[1]{``#1''}

\newminted[code]{cpp}{
	bgcolor=pybg,
	baselinestretch=1.2,
	fontsize=\normalsize,
	tabsize=0,
	linenos,
	obeytabs=true,
	tabsize=4
}

\begin{document}
	\begin{titlepage}
		\begin{center}
			МИНИСТЕРСТВО НАУКИ И ВЫСШЕГО ОБРАЗОВАНИЯ\linebreak 
			РОССИЙСКОЙ ФЕДЕРАЦИИ\medskip
			
			ФЕДЕРАЛЬНОЕ ГОСУДАРСТВЕННОЕ БЮДЖЕТНОЕ ОБРАЗОВАТЕЛЬНОЕ 
			УЧРЕЖДЕНИЕ ВЫСШЕГО ОБРАЗОВАНИЯ\medskip
			
			\textbf{
				«БЕЛГОРОДСКИЙ ГОСУДАРСТВЕННЫЙ \linebreak
				ТЕХНОЛОГИЧЕСКИЙ УНИВЕРСИТЕТ им. В. Г. ШУХОВА»\linebreak
				(БГТУ им. В.Г. Шухова)
			}\bigskip
			
			Кафедра программного обеспечения вычислительной техники и автоматизированных систем
			\vspace{5cm}
			
			\Large\textbf{Лабораторная работа №4}
			
			\large по дисциплине: Исследование операций\linebreak
			тема: \q{Закрытая транспортная задача}
		\end{center}\vspace{6cm}
		
		\begin{flushright}
			\begin{minipage}{7cm}
				Выполнил: ст. группы ПВ-231\\
				Столяров Захар\\
				\\
				Проверил: \\
				Вирченко Юрий Петрович\\
			\end{minipage}
		\end{flushright}\bigskip
		
		\
		
		\
		
		\
		
		\
		
		
		\begin{center}
			Белгород, 2025 г.
		\end{center}
	\end{titlepage}
	
	\newpage
	
	\setcounter{secnumdepth}{-1}
	\chapter{Лабораторная работа №4 <<Закрытая транспортная задача.>>}
	
	\textbf{Цель работы:} изучить математическую модель транспортной
	задачи, овладеть методами решения этой задачи.
	\begin{center}
		\textbf{Вариант 14}
	\end{center}
	\begin{center}
		\textbf{Задания для подготовки к работе}
	\end{center}
	
	\begin{enumerate}
		\item{Изучить содержательную и математическую постановки закрытой
			транспортной задачи, методы нахождения первого опорного
			решения ее системы ограничений. Изучить понятие цикла
			пересчета в матрице перевозок. Овладеть распределительным
			методом и методом потенциалов, а также их алгоритмами.} 
		\item{Составить и отладить программы решения транспортной задачи
			распределительным методом и методом потенциалов.} 
		\item{В рамках подготовки тестовых
			данных решить аналитически следующую задачу:}
	\end{enumerate}
	
	\begin{center}\Large
		$\vec{a} = (23, 24, 21, 15);$
	\end{center}
	
	\begin{center}\Large
		$\vec{b} = (19, 16, 16, 16, 16);$
	\end{center}
	
	\begin{center}
		{
			\Large\[
			\begin{pmatrix}
				8 & 28 & 17 & 19 & 11 \\
				27 & 5 & 10 & 6 & 19 \\
				29 & 11 & 3 & 7 & 8  \\
				25 & 16 & 19 & 24 & 13  \\
			\end{pmatrix}
			\]
		}
	\end{center}
	

	
	\newpage
	
	\chapter{Программное решение}
	
	\section{Блок-схемы основных функций программ:}
	
\begin{center}
	\begin{tikzpicture}[node distance=1.8cm]
		\node (term) [rec] {solve\_distributive\_method(a, b, C)};
		\node (1) [proc, below of=term] {Инициализация: total\_sum = 0};
		\node (2) [proc, below of=1] {total\_b = сумма всех b};
		\node (cyc1) [dec, below of=2, yshift = -1.5cm] {Пока total\_b > 0};
		\node (3) [proc, below of=cyc1, yshift = -1.5cm] {total\_sum += get\_step(a, b, C)};
		\node (4) [proc, below of=3] {total\_b = сумма всех b};
		\node (pizda) [rec, below of=4] {Возврат total\_sum};
		
		\draw[con] (term) -- (1);
		\draw[con] (1) -- (2);
		\draw[con] (2) -- (cyc1);
		\draw[con] (cyc1) -- node[right] {} (3);
		\draw[con] (3) -- (4);
		\draw[con] (4) -- ++(0,-0.8) -- ++(-4,0) |- (cyc1.west);
		\draw[con] (cyc1.east) -- ++(2,0) -- ++(0, -6.2) -| (pizda.north);
	\end{tikzpicture}
\end{center}

\newpage

\begin{center}
	\begin{tikzpicture}[node distance=1.8cm]
		\node (term) [rec] {get\_step(a, b, C)};
		\node (1) [proc, below of=term] {Находим минимальную стоимость перевозки};
		\node (2) [proc, below of=1] {Определяем количество перевезённого груза};
		\node (3) [proc, below of=2] {Корректируем запас и потребности};
		\node (4) [proc, below of=3] {Считаем стоимость перевозки};
		\node (5) [proc, below of=4] {Присваиваем текущей клетке матрицы очень большое число};
		\node (pizda) [rec, below of=5] {Стоимость перевозки};
		
		\draw[con] (term) -- (1);
		\draw[con] (1) -- (2);
		\draw[con] (2) -- (3);
		\draw[con] (3) -- (4);
		\draw[con] (4) -- (5);
		\draw[con] (5) -- (pizda);
	\end{tikzpicture}
\end{center}
	
	\newpage
	
\begin{center}
	\begin{tikzpicture}[node distance=1.8cm]
		\node (term) [rec] {find\_cycle(basis, entering\_cell)};
		\node (1) [proc, below of=term] {Строим граф базисных клеток};
		\node (2) [proc, below of=1] {Добавляем входящую клетку в граф};
		\node (3) [proc, below of=2] {Начиная со строки входящей клетки ищем цикл};
		\node (4) [proc, below of=3] {Преобразуем цикл в координаты клеток};
		\node (pizda) [rec, below of=4] {Цикл пересчёта};
		
		\draw[con] (term) -- (1);
		\draw[con] (1) -- (2);
		\draw[con] (2) -- (3);
		\draw[con] (3) -- (4);
		\draw[con] (4) -- (pizda);
	\end{tikzpicture}
\end{center}

\newpage

\drawzalupa{images/block.png}{0.5}

\newpage


	\section{Распределительный метод}
	
	\section{Код программы:}
	\begin{code}
#include <iostream>
#include <vector>
#include <climits>

using namespace std;

int get_step(vector<int>& a, vector<int>& b, vector<vector<int>>& C) {
	int min_el = C[0][0];
	pair<int, int> min_el_ind = { 0, 0 };
	
	// Находим минимальную стоимость перевозки
	for (size_t i = 0; i < a.size(); ++i) {
		for (size_t j = 0; j < b.size(); ++j) {
			if (C[i][j] < min_el) {
				min_el = C[i][j];
				min_el_ind = { i, j };
			}
		}
	}
	
	// Количество перевезённого груза
	int sum = min(a[min_el_ind.first], b[min_el_ind.second]);
	
	// Корректируем запас и потребность
	a[min_el_ind.first] -= sum;
	b[min_el_ind.second] -= sum;
	
	// Считаем стоимость перевозки
	sum *= C[min_el_ind.first][min_el_ind.second];
	
	// Помечаем клетку как использованную
	C[min_el_ind.first][min_el_ind.second] = INT_MAX;
	
	return sum;
}

int solve_distributive_method(vector<int>& a, vector<int>& b, vector<vector<int>>& C) {
	int total_sum = 0;
	
	// Выполняем шаги пока есть потребности
	int total_b = 0;
	for (int val : b) total_b += val;
	
	while (total_b > 0) {
		total_sum += get_step(a, b, C);
		total_b = 0;
		for (int val : b) total_b += val;
	}
	
	return total_sum;
}

int main() {
	setlocale(LC_ALL, "Russian");
	
	vector<int> a = { 23, 24, 21, 15 };       // Вектор запасов
	vector<int> b = { 19, 16, 16, 16, 16 };   // Вектор потребностей
	vector<vector<int>> C = {                // Матрица стоимостей
		{8, 28, 17, 19, 11},
		{27, 5, 10, 6, 19},
		{29, 11, 3, 7, 8},
		{25, 16, 19, 24, 13}
	};
	
	int result = solve_distributive_method(a, b, C);
	cout << "Минимальная стоимость перевозок: " << result << endl;
	
	return 0;
}
	\end{code}
	
	Результат работы программы:
	
	\drawzalupa{images/task1.png}{1}
	
	\newpage
	
	\section{Метод потенциалов}
	
	\section{Код программы:}
	
	\begin{code}
#include <iostream>
#include <vector>
#include <limits>
#include <algorithm>
#include <unordered_map>
#include <unordered_set>
#include <stack>
#include <string>
#include <sstream>

using namespace std;

const int INF = numeric_limits<int>::max();

struct Cell {
	int i, j;
};

vector<Cell> find_cycle(const vector<Cell>& basis, Cell entering_cell) {
	unordered_map<string, vector<string>> graph;
	unordered_map<string, string> parent;
	unordered_set<string> visited;
	
	// Строим граф
	for (size_t idx = 0; idx < basis.size(); ++idx) {
		const Cell& cell = basis[idx];
		string row = "r" + std::to_string(cell.i);
		string col = "c" + std::to_string(cell.j);
		graph[row].push_back(col);
		graph[col].push_back(row);
	}
	
	// Добавляем входящую клетку
	string start_row = "r" + std::to_string(entering_cell.i);
	string start_col = "c" + std::to_string(entering_cell.j);
	graph[start_row].push_back(start_col);
	graph[start_col].push_back(start_row);
	
	// Ищем цикл
	stack<pair<string, string>> s;
	s.push(make_pair(start_row, ""));
	vector<string> cycle;
	
	while (!s.empty()) {
		pair<string, string> node_pair = s.top();
		s.pop();
		string node = node_pair.first;
		string prev = node_pair.second;
		
		if (visited.count(node)) {
			// Нашли цикл
			string current = node;
			while (current != "") {
				cycle.push_back(current);
				current = parent[current];
			}
			reverse(cycle.begin(), cycle.end());
			break;
		}
		
		visited.insert(node);
		parent[node] = prev;
		
		for (size_t i = 0; i < graph[node].size(); ++i) {
			const string& neighbor = graph[node][i];
			if (neighbor != prev) {
				s.push(make_pair(neighbor, node));
			}
		}
	}
	
	// Преобразуем в координаты клеток
	vector<Cell> cycle_coords;
	for (size_t i = 0; i < cycle.size(); ++i) {
		if (cycle[i][0] == 'r') {
			if (i + 1 < cycle.size()) {
				string row_str = cycle[i].substr(1);
				string col_str = cycle[i + 1].substr(1);
				int row = atoi(row_str.c_str());
				int col = atoi(col_str.c_str());
				cycle_coords.push_back({ row, col });
			}
		}
	}
	
	return cycle_coords;
}

vector<vector<int>> solve_potentials_method(vector<int> a, vector<int> b, vector<vector<int>> C) {
	int m = static_cast<int>(a.size());
	int n = static_cast<int>(b.size());
	vector<vector<int>> X(m, vector<int>(n, 0));
	vector<int> remaining_a = a;
	vector<int> remaining_b = b;
	
	// Построение начального опорного плана методом минимальной стоимости
	while (true) {
		bool has_remaining = false;
		for (size_t i = 0; i < remaining_a.size(); ++i) {
			if (remaining_a[i] > 0) {
				has_remaining = true;
				break;
			}
		}
		if (!has_remaining) break;
		
		int min_cost = INF;
		Cell min_cell = { -1, -1 };
		
		for (int i = 0; i < m; ++i) {
			for (int j = 0; j < n; ++j) {
				if (remaining_a[i] > 0 && remaining_b[j] > 0 && C[i][j] < min_cost) {
					min_cost = C[i][j];
					min_cell.i = i;
					min_cell.j = j;
				}
			}
		}
		
		if (min_cell.i == -1) break;
		
		int amount = min(remaining_a[min_cell.i], remaining_b[min_cell.j]);
		X[min_cell.i][min_cell.j] = amount;
		remaining_a[min_cell.i] -= amount;
		remaining_b[min_cell.j] -= amount;
	}
	
	// Метод потенциалов
	int iteration = 0;
	const int max_iterations = 100;
	
	while (iteration++ < max_iterations) {
		vector<int> u(m, 0);
		vector<int> v(n, 0);
		vector<Cell> basis;
		
		// Собираем базисные клетки
		for (int i = 0; i < m; ++i) {
			for (int j = 0; j < n; ++j) {
				if (X[i][j] > 0) {
					Cell cell;
					cell.i = i;
					cell.j = j;
					basis.push_back(cell);
				}
			}
		}
		
		// Вычисляем потенциалы
		bool changed;
		do {
			changed = false;
			for (size_t idx = 0; idx < basis.size(); ++idx) {
				const Cell& cell = basis[idx];
				if (u[cell.i] != 0 && v[cell.j] == 0) {
					v[cell.j] = C[cell.i][cell.j] - u[cell.i];
					changed = true;
				}
				else if (v[cell.j] != 0 && u[cell.i] == 0) {
					u[cell.i] = C[cell.i][cell.j] - v[cell.j];
					changed = true;
				}
			}
		} while (changed);
		
		// Проверка оптимальности
		bool optimal = true;
		Cell entering_cell = { -1, -1 };
		int min_delta = 0;
		
		for (int i = 0; i < m; ++i) {
			for (int j = 0; j < n; ++j) {
				if (X[i][j] == 0) {
					int delta = C[i][j] - (u[i] + v[j]);
					if (delta < min_delta) {
						min_delta = delta;
						optimal = false;
						entering_cell.i = i;
						entering_cell.j = j;
					}
				}
			}
		}
		
		if (optimal) break;
		
		// Находим цикл пересчета
		vector<Cell> cycle = find_cycle(basis, entering_cell);
		
		// Находим минимальное значение в минусовых клетках
		int theta = INF;
		for (size_t i = 1; i < cycle.size(); i += 2) {
			theta = min(theta, X[cycle[i].i][cycle[i].j]);
		}
		
		// Корректируем план
		for (size_t i = 0; i < cycle.size(); ++i) {
			int row = cycle[i].i;
			int col = cycle[i].j;
			if (i % 2 == 0) { // Плюсовые клетки
				X[row][col] += theta;
			}
			else { // Минусовые клетки
				X[row][col] -= theta;
			}
		}
	}
	
	return X;
}

int main() {
	setlocale(LC_ALL, "Russian");
	
	vector<int> a = { 23, 24, 21, 15 };
	vector<int> b = { 19, 16, 16, 16, 16 };
	vector<vector<int>> C = {
		{8, 28, 17, 19, 11},
		{27, 5, 10, 6, 19},
		{29, 11, 3, 7, 8},
		{25, 16, 19, 24, 13}
	};
	
	vector<vector<int>> solution = solve_potentials_method(a, b, C);
	
	// Вычисляем общую стоимость
	int total_cost = 0;
	for (size_t i = 0; i < solution.size(); ++i) {
		for (size_t j = 0; j < solution[i].size(); ++j) {
			total_cost += solution[i][j] * C[i][j];
		}
	}
	
	cout << "Минимальная стоимость перевозок: " << total_cost << endl;
	
	return 0;
}		
	\end{code}
	
	Результат работы программы:
	
	\drawzalupa{images/task2.png}{1}
	
	\newpage
	
	\chapter{Аналитическое решение}
\begin{enumerate}
	\item \textbf{Теоретические сведения}
	
	\begin{itemize}
		\item Имеется 4 поставщика с запасами $a = (23, 24, 21, 15)$
		\item Имеется 5 потребителей с потребностями $b = (19, 16, 16, 16, 16)$
		\item Матрица стоимостей перевозок:
		\[
		C = \begin{pmatrix}
			8 & 28 & 17 & 19 & 11 \\
			27 & 5 & 10 & 6 & 19 \\
			29 & 11 & 3 & 7 & 8 \\
			25 & 16 & 19 & 24 & 13 \\
		\end{pmatrix}
		\]
	\end{itemize}
	
	\item \textbf{Решение методом минимальной стоимости}
	
	\begin{enumerate}
		\item Пошаговое решение:
		
		\begin{itemize}
			\item Шаг 1: Клетка (3,3), стоимость 3, перевозим 16 ед. \\
			Стоимость: $16 \times 3 = 48$
			
			\item Шаг 2: Клетка (2,4), стоимость 6, перевозим 16 ед. \\
			Стоимость: $48 + 16 \times 6 = 144$
			
			\item Шаг 3: Клетка (2,2), стоимость 5, перевозим 8 ед. \\
			Стоимость: $144 + 8 \times 5 = 184$
			
			\item Шаг 4: Клетка (4,5), стоимость 13, перевозим 15 ед. \\
			Стоимость: $184 + 15 \times 13 = 379$
			
			\item Шаг 5: Клетка (1,1), стоимость 8, перевозим 19 ед. \\
			Стоимость: $379 + 19 \times 8 = 531$
			
			\item Шаг 6: Клетка (1,5), стоимость 11, перевозим 4 ед. \\
			Стоимость: $531 + 4 \times 11 = 575$
			
			\item Шаг 7: Клетка (3,5), стоимость 8, перевозим 1 ед. \\
			Стоимость: $575 + 1 \times 8 = 583$
			
			\item Шаг 8: Клетка (1,3), стоимость 17, перевозим 3 ед. \\
			Стоимость: $583 + 3 \times 17 = 634$
			
			\item Шаг 9: Клетка (2,3), стоимость 10, перевозим 1 ед. \\
			Стоимость: $634 + 1 \times 10 = \boxed{635}$
		\end{itemize}
		
		\item Таблица итогового распределения:
		
		\begin{center}
			\begin{tabular}{|c|c|c|c|c|c|c|}
				\hline
				& $b_1=19$ & $b_2=16$ & $b_3=16$ & $b_4=16$ & $b_5=16$ & Запасы \\ \hline
				$a_1=23$ & \textbf{19} & -- & \textbf{3} & -- & \textbf{4} & 0 \\ \hline
				$a_2=24$ & -- & \textbf{8} & \textbf{1} & \textbf{16} & -- & 0 \\ \hline
				$a_3=21$ & -- & -- & \textbf{16} & -- & \textbf{1} & 4 \\ \hline
				$a_4=15$ & -- & -- & -- & -- & \textbf{15} & 0 \\ \hline
			\end{tabular}
		\end{center}
		
		\item Общая минимальная стоимость перевозок: \boxed{635}
	\end{enumerate}
\end{enumerate}
	
	\textbf{Вывод: }результат аналитического решения совпадает с результатами написанных мной обеих программ, что подтверждает корректность моего решения методом минимальной стоимости, методом потенциалов и распределительным методом.
\end{document}

